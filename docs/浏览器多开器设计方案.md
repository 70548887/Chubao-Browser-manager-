## 浏览器多开器整体设计方案

### 1. 项目目标与整体思路

**目标**：在 Windows 平台实现一个「浏览器多开模拟器」，让用户通过一个本地 exe 管理多个独立浏览器实例，每个实例等价于一台“虚拟手机”：

- 每个实例独立配置目录 + 无痕模式，**会话完全隔离**；
- 浏览器中预装 **Chrome 扩展**，扩展通过 WebSocket 连接后台 Go 服务端；
- 有 Go 服务端时：可进行远程脚本控制、任务编排、数据回传；
- 没有 Go 服务端时：仍然可以作为 **纯本地多开器** 使用，仅做多开 + 窗口管理。

系统采用「**本地去中心化创建，服务端被动接入**」的设计：  
**窗口的创建/关闭完全由本地管理端决定，Go 服务端只负责发现和管理已连接的设备。**

---

### 2. 系统角色与边界

#### 2.1 本地管理端（Windows 模拟器管理器）

- 形式：一个 Windows 可执行程序（exe）
- 核心职责：
  - 启动/关闭多个独立的 Chrome 实例（每个实例 = 一台虚拟手机）
  - 为每个实例分配独立 `user-data-dir`，并以无痕模式运行
  - 控制每个实例的窗口状态：显示 / 隐藏 / 最小化 / 调整位置
  - 通过 WebSocket/HTTP 与 Go 服务端同步设备状态（在线/离线、任务信息等）
  - 提供图形界面展示：
    - 当前虚拟手机数量
    - 每台手机的本地状态（进程、窗口）
    - 每台手机的 WebSocket 连接状态（是否连上 Go）

> 本地管理端不负责 JS 业务逻辑，只负责「开几台手机、手机外壳的生命周期和可见性」。

#### 2.2 Chrome 浏览器实例（虚拟手机）

- 每个实例等价于一台独立手机：
  - 独立 `user-data-dir`（独立配置目录）
  - 无痕模式（Incognito），会话彼此隔离
- 启动命令统一由本地管理端构造，例如：
  - `chrome.exe --user-data-dir=<profileDir> --incognito --load-extension=<extDir> --new-window "<bootstrap-url>?localId=XXX"`
- 实例内预装指定的 Chrome 扩展，用于：
  - 建立到 Go 服务端的 WebSocket 连接
  - 执行 Go 下发的控制命令（打开页面、执行 JS 等）
  - 上报当前页面状态和运行数据

#### 2.3 Chrome 扩展（控制代理）

- 以 Manifest V3 为基础，包含：
  - **Background Service Worker**：长连接、消息路由、调用 `chrome.tabs` / `chrome.windows`
  - **Content Scripts**：注入到具体网站页面中执行 DOM 操作、监听播放器/WebSocket 等
- 核心职责：
  - 自动连接 Go 服务端（WebSocket）
  - 按约定协议上报设备信息、页面状态
  - 接收 Go 的控制指令：
    - 打开指定 URL
    - 执行 JS 片段
    - 控制 Tab/窗口行为

扩展对 Go 的连接具备容错性：

- 连接成功：进入联控模式，按指令运行脚本；
- 连接失败：仅自动重试，不影响浏览器正常使用，本地多开器仍可正常工作。

#### 2.4 Go 服务端（控制中枢）

- 作为所有「虚拟手机」的控制中枢，负责：
  - 接收来自各个扩展的 WebSocket 连接
  - 维护每台设备的状态：`deviceId / localId / 用户 / 当前任务 / 在线状态`
  - 根据业务逻辑，向扩展下发控制指令（执行脚本、跳转 URL、心跳控制等）
  - 通过 WebSocket/HTTP 与本地管理端同步设备整体状态（供界面展示）

服务端不参与「是否允许创建窗口」的决策，**只对已经连接上来的设备进行管理和下发任务**。

---

### 3. 运行模式设计

#### 3.1 离线多开模式（无 Go 服务端）

- 场景：用户未启动或未配置 Go 服务端
- 行为：
  - 本地管理端照常：
    - 多开 Chrome 实例（虚拟手机）
    - 控制窗口显示/隐藏
    - 统计本地正在运行的实例数量
  - 扩展尝试连接 Go 失败后：
    - 静默重试或定时重连
    - 不弹出错误提示、不影响用户使用
- 结果：  
  本地管理端退化为 **纯浏览器多开器/模拟器**，仅提供多开 + 窗口管理能力。

#### 3.2 联控模式（Go 服务端在线）

- 场景：Go 服务端正常运行
- 行为流程：
  1. 管理端多开浏览器 → 每个实例内扩展启动并自动 WebSocket 连接 Go
  2. Go 为每个连接分配 `deviceId`，记录设备信息
  3. Go 将设备在线状态、当前任务等信息推送给管理端
  4. 管理端 UI 显示：
     - 每台虚拟手机的在线状态（WS 已连接/未连接）
     - 当前 URL / 任务状态（由 Go 提供）
  5. Go 根据业务逻辑下发控制指令，扩展执行，页面产生实际行为

---

### 4. 本地管理端设计详情

#### 4.1 核心模块

- **DeviceManager（设备管理器）**
  - 维护「虚拟手机」列表
  - 提供增删改查接口：
    - 新建设备（生成 `localId`、分配 `profileDir`）
    - 更新本地/远程状态（`pid`、`windowHandle`、`wsOnline` 等）
    - 关闭设备并清理状态

- **ProcessLauncher（进程启动器）**
  - 根据参数启动 Chrome 实例：
    - `--user-data-dir=<profileDir>`
    - `--incognito`
    - `--load-extension=<extDir>`
    - `--new-window "<bootstrap-url>?localId=XXX"`
  - 记录启动成功后的 `pid`，并回传给 DeviceManager
  - 提供安全关闭 / 强制 kill 接口

- **WindowController（窗口控制器）**
  - 通过 PID 寻找窗口句柄（WinAPI）
  - 提供：
    - 显示 / 隐藏 / 最小化 / 还原
    - 调整窗口位置/大小（支持网格布局、一键排布）

- **GoClient（服务端客户端）**
  - 与 Go 服务端保持 WebSocket/HTTP 连接
  - 接收服务端推送的设备状态：
    - `deviceId`、`wsOnline`、当前任务、URL 等
  - （可选）汇报本地状态给 Go：
    - 窗口是否在前台（visible）、是否被用户手动隐藏

- **UI 层**
  - 展示设备列表：
    - 序号、`localId`、`deviceId`
    - WS 状态（在线/离线）
    - 窗口状态（显示/隐藏）
    - 当前 URL、运行时长
  - 操作按钮：
    - 新建虚拟手机（可指定数量）
    - 关闭指定手机
    - 显示/隐藏指定窗口
    - 一键排列所有窗口

#### 4.2 设备数据模型（示例）

每台虚拟手机（设备）可用类似结构描述：

- **`localId`**：本地唯一标识（如 `local-20260108-0001`）
- **`deviceId`**：Go 服务端分配的设备 ID（无 Go 时为空）
- **`profileDir`**：该实例使用的 `user-data-dir` 路径
- **`pid`**：对应 Chrome 进程 PID
- **`windowHandle`**：窗口句柄（用于窗口控制）
- **`visible`**：当前是否在前台显示
- **`wsOnline`**：扩展与 Go 的 WebSocket 是否已连接
- **`currentUrl`**：当前访问的 URL（由 Go 端状态或扩展上报提供）
- **`createdAt` / `lastHeartbeatAt`**：创建时间 / 最近心跳时间

---

### 5. 典型业务流程

#### 5.1 新建虚拟手机（本地创建，不依赖 Go 授权）

1. 用户在管理端点击「新增 1 台手机」
2. `DeviceManager`：
   - 生成 `localId`
   - 计算 `profileDir` 路径
3. `ProcessLauncher`：
   - 构造命令行启动 Chrome：
     - 带上 `user-data-dir`、无痕、扩展目录、附带 `localId` 的初始 URL
   - 获取 `pid` 并回填到设备记录
4. `WindowController` 根据 `pid` 找到窗口句柄，记录 `windowHandle`
5. UI 即刻展示新设备：
   - 状态：`wsOnline=false`，`visible=true`，`deviceId` 为空
6. 若 Go 在线，扩展成功连上 Go 后：
   - Go 端通过 `GoClient` 推送 `deviceId`、`wsOnline=true`
   - 管理端更新设备行的远程状态

#### 5.2 关闭虚拟手机

1. 用户点击某行的「关闭」
2. 管理端通过 `DeviceManager` 查出该设备的 `pid`
3. `ProcessLauncher` 结束对应 Chrome 进程
4. 扩展 WS 连接断开，Go 端检测到设备离线，推送状态更新
5. 管理端更新/删除对应设备记录

#### 5.3 隐藏 / 显示窗口（模拟息屏/亮屏）

1. 用户点击某行的「隐藏」
2. 管理端通过 `WindowController` 对应 `windowHandle` 执行隐藏/最小化操作
3. 更新设备状态：`visible=false`
4. （可选）通过 `GoClient` 通知 Go 端该设备进入后台状态

反之，「显示」则恢复窗口显示位置，并标记 `visible=true`。

---

### 6. Chrome 扩展设计要点（简要）

- **启动时行为：**
  - 从 URL 或 `chrome.storage` 中读取 `localId`
  - 建立 WebSocket 到 Go 服务端：
    - 成功：发送 `device_hello(localId, ua, extra)`，获取 `deviceId`
    - 失败：定时重试，不打扰用户

- **消息处理：**
  - 来自 Go：
    - `open_url`：`chrome.tabs.update` 或 `chrome.tabs.create`
    - `execute_js`：通过 `chrome.scripting.executeScript` 在页面中执行 JS
    - 其他业务指令（具体由 Go 定义）
  - 发送给 Go：
    - 状态上报（当前 URL、页面运行状态、心跳等）
    - 错误与日志

---

### 7. Go 服务端角色（简要）

- 管理设备连接：
  - 建立 `localId ↔ deviceId ↔ userId` 映射
  - 维护设备在线列表和任务状态
- 作为控制中心：
  - 接收上层业务请求（比如新任务、批量控制）
  - 通过 WebSocket 向各扩展下发命令
- 与本地管理端同步状态（可选）：
  - 推送设备上线/下线、自身分配的 `deviceId`、当前任务状态等

---

### 8. 技术栈概览

- **本地管理端（Windows 模拟器管理器）**：
  - 开发语言：可选 Go（配合 Wails/WebView）、C#（WPF/WinUI）或 Electron/Tauri（前端 + Node）。
  - 能力要求：进程管理（启动/关闭 Chrome）、窗口控制（WinAPI）、WebSocket/HTTP 客户端。
  - 推荐方案：
    - 若你团队以 Go 为主：优先考虑 **Go + Wails**，方便代码复用与部署；
    - 若偏向桌面原生体验：可选 **C# + WPF/WinUI**，对窗口/句柄控制更直接；
    - 若前端能力强：可选 **Electron/Tauri**，UI 开发效率高。
- **浏览器实例（Chrome/Chromium）**：
  - 每个实例独立 `user-data-dir` + 无痕模式（Incognito），模拟一台独立设备。
  - 通过启动参数加载指定扩展，并附带 `localId` 等标识信息，确保扩展能识别所属“虚拟手机”。
  - 可结合命令行参数控制：禁用 GPU、限制缓存大小、指定语言/地区等，以降低资源占用和统一指纹特征。
- **Chrome 扩展（控制代理）**：
  - 技术：Manifest V3、Background Service Worker、Content Scripts。
  - 能力：WebSocket 客户端、`chrome.tabs` / `chrome.windows` / `chrome.scripting` API 调用、`chrome.storage` 存储本地配置。
  - 关键点：
    - 使用浏览器原生 `WebSocket`，实现自动重连与心跳保活；
    - 通过 `chrome.storage` 或启动 URL 传递 `localId`，保证设备标识稳定；
    - content script 中尽量只做「页面适配」，复杂业务逻辑尽量放在 Go 服务端。
- **Go 服务端（控制中枢）**：
  - 开发语言：Go，使用标准库或常见 WebSocket/HTTP 框架（如 `net/http` + `gorilla/websocket`）。
  - 能力：设备连接管理、消息路由（管理端 ↔ 扩展）、任务调度与状态存储。
  - 建议：
    - 使用结构化日志和统一 TraceId 方便排查多设备并发问题；
    - 将设备状态与任务状态存入 Redis/数据库，支撑断线恢复与多节点扩展；
    - 为 WebSocket 通道设计简洁稳定的 JSON 协议，便于后续扩展。

---

### 9. 总结

这套方案实现了一个 **去中心化创建、中心化联控** 的浏览器多开模拟器：

- **本地管理端** 负责：多开、窗口管理、进程生命周期、基本状态展示；
- **Chrome 浏览器实例 + 扩展** 负责：真实页面环境、WebSocket 通道、执行控制命令；
- **Go 服务端** 负责：设备管理、脚本控制、协议逻辑和任务调度；
- **有无 Go 服务端都可用**：
  - 无 Go：本地多开 + 窗口控制；
  - 有 Go：多开基础上叠加远程脚本控制与数据回传。
