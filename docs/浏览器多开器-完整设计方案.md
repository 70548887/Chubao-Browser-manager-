# Rust + Tauri 反指纹浏览器多开器完整设计方案

> 本文档合并自两份设计文档，涵盖方案概述、技术架构和完整实现细节。

---

## 一、方案概述

### 1.1 核心思路

**不修改、不编译 Chromium，直接使用 fingerprint-chromium 预编译版本**

- **浏览器层**：fingerprint-chromium（预编译二进制，底层已实现指纹修改）
- **管理层**：Rust + Tauri 启动器（负责多开、窗口管理、CDP控制）
- **业务层**：Go 服务端（脚本管理、任务调度、设备管理）

### 1.2 方案优势

| 优势 | 说明 |
|------|------|
| ✅ 无需编译 Chromium | 节省数周时间和 100GB+ 磁盘 |
| ✅ 指纹效果优秀 | 底层 C++ 修改，无法被 JS 检测 |
| ✅ 开发效率高 | 只需开发启动器，4周完成 |
| ✅ 职责分离清晰 | 浏览器/管理/业务三层解耦 |
| ✅ 易于维护升级 | fingerprint-chromium 社区维护 |
| ✅ 极小打包体积 | ~5MB vs Electron ~200MB |
| ✅ 低内存占用 | 管理器仅 ~20MB |

### 1.3 项目目标

构建一个高性能、低资源占用的 Windows PC端浏览器多开管理器，实现：

- 多开 fingerprint-chromium 浏览器实例
- 每个实例独立指纹配置
- 通过 CDP 协议执行脚本（无扩展痕迹）
- 窗口显示/隐藏/排列管理
- 与 Go 服务端 WebSocket 通信

### 1.4 技术选型

| 层级 | 技术 | 说明 |
|------|------|------|
| **桌面框架** | Tauri 2.0 | 轻量级，打包仅3-8MB |
| **后端语言** | Rust | 高性能，低内存占用 |
| **CDP库** | chromiumoxide | Rust异步CDP库 |
| **异步运行时** | Tokio | 高性能异步运行时 |
| **Windows API** | windows-rs | 原生窗口控制 |
| **前端框架** | Vue 3 + TypeScript | 响应式UI |
| **状态管理** | Pinia | Vue状态管理 |
| **UI组件** | Element Plus | 成熟UI库 |
| **浏览器** | fingerprint-chromium | 底层指纹修改 |

---

## 二、系统架构

### 2.1 架构图

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                              系统架构                                            │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│                          Go 服务端 (已有)                                        │
│                    ┌──────────────────────────┐                                 │
│                    │  • 设备管理               │                                 │
│                    │  • 脚本管理与下发          │                                 │
│                    │  • 任务调度               │                                 │
│                    │  • 状态监控               │                                 │
│                    └────────────┬─────────────┘                                 │
│                                 │ WebSocket                                     │
│                                 ▼                                               │
│       ┌───────────────────────────────────────────────────────────────┐         │
│       │             Tauri App (本项目核心)                            │         │
│       │                                                               │         │
│       │  ┌─────────────────────────────────────────────────────────┐ │         │
│       │  │                    Rust Backend                         │ │         │
│       │  │                                                         │ │         │
│       │  │  ┌───────────┐ ┌───────────┐ ┌───────────┐ ┌──────────┐│ │         │
│       │  │  │ Profile   │ │ Browser   │ │ CDP       │ │ Window   ││ │         │
│       │  │  │ Manager   │ │ Launcher  │ │ Manager   │ │ Manager  ││ │         │
│       │  │  └───────────┘ └───────────┘ └───────────┘ └──────────┘│ │         │
│       │  │                                                         │ │         │
│       │  │  ┌───────────┐ ┌───────────┐ ┌───────────┐             │ │         │
│       │  │  │ Server    │ │ State     │ │ Config    │             │ │         │
│       │  │  │ Client    │ │ Store     │ │ Manager   │             │ │         │
│       │  │  └───────────┘ └───────────┘ └───────────┘             │ │         │
│       │  └─────────────────────────────────────────────────────────┘ │         │
│       │                              │                               │         │
│       │                              │ Tauri IPC                     │         │
│       │                              ▼                               │         │
│       │  ┌─────────────────────────────────────────────────────────┐ │         │
│       │  │                    Vue 3 Frontend                       │ │         │
│       │  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐       │ │         │
│       │  │  │ 设备列表 │ │ 指纹配置 │ │ 窗口控制 │ │ 任务监控 │       │ │         │
│       │  │  └─────────┘ └─────────┘ └─────────┘ └─────────┘       │ │         │
│       │  └─────────────────────────────────────────────────────────┘ │         │
│       └───────────────────────────────────────────────────────────────┘         │
│                                  │                                              │
│                                  │ CDP Protocol + 启动参数                       │
│                                  ▼                                              │
│  ┌───────────────────────────────────────────────────────────────────────┐      │
│  │          fingerprint-chromium 实例 ×N (预编译版本，不需要修改)         │      │
│  │  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐                  │      │
│  │  │ 实例1   │  │ 实例2   │  │ 实例3   │  │ 实例N   │                  │      │
│  │  │ 指纹A   │  │ 指纹B   │  │ 指纹C   │  │ 指纹N   │                  │      │
│  │  │ CDP:9222│  │ CDP:9223│  │ CDP:9224│  │ CDP:...│                  │      │
│  │  └─────────┘  └─────────┘  └─────────┘  └─────────┘                  │      │
│  └───────────────────────────────────────────────────────────────────────┘      │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 项目目录结构

```
browser-manager/
├── src-tauri/                      # Rust 后端
│   ├── src/
│   │   ├── main.rs                 # 入口文件
│   │   ├── lib.rs                  # 库导出
│   │   ├── commands/               # Tauri Commands
│   │   │   ├── mod.rs
│   │   │   ├── browser.rs          # 浏览器控制命令
│   │   │   ├── profile.rs          # 配置文件命令
│   │   │   ├── window.rs           # 窗口控制命令
│   │   │   └── server.rs           # 服务端通信命令
│   │   ├── managers/               # 核心管理器
│   │   │   ├── mod.rs
│   │   │   ├── profile_manager.rs  # 指纹配置管理
│   │   │   ├── browser_manager.rs  # 浏览器进程管理
│   │   │   ├── cdp_manager.rs      # CDP连接管理
│   │   │   ├── window_manager.rs   # 窗口管理
│   │   │   └── server_client.rs    # 服务端WebSocket客户端
│   │   ├── models/                 # 数据模型
│   │   │   ├── mod.rs
│   │   │   ├── profile.rs          # 配置文件模型
│   │   │   ├── device.rs           # 设备模型
│   │   │   ├── fingerprint.rs      # 指纹模型
│   │   │   └── message.rs          # 消息模型
│   │   ├── utils/                  # 工具函数
│   │   │   ├── mod.rs
│   │   │   ├── fingerprint_gen.rs  # 指纹生成
│   │   │   ├── port_finder.rs      # 端口查找
│   │   │   └── path_helper.rs      # 路径处理
│   │   ├── state.rs                # 全局状态
│   │   ├── config.rs               # 配置文件
│   │   └── error.rs                # 错误处理
│   ├── Cargo.toml                  # Rust依赖
│   ├── tauri.conf.json             # Tauri配置
│   └── build.rs                    # 构建脚本
├── src/                            # Vue 前端
│   ├── assets/                     # 静态资源
│   ├── components/                 # 通用组件
│   │   ├── DeviceCard.vue          # 设备卡片
│   │   ├── FingerprintEditor.vue   # 指纹编辑器
│   │   ├── WindowGrid.vue          # 窗口网格
│   │   └── StatusBar.vue           # 状态栏
│   ├── views/                      # 页面视图
│   │   ├── DeviceList.vue          # 设备列表页
│   │   ├── ProfileManager.vue      # 配置管理页
│   │   ├── TaskMonitor.vue         # 任务监控页
│   │   └── Settings.vue            # 设置页
│   ├── stores/                     # Pinia状态
│   ├── api/                        # Tauri API封装
│   ├── types/                      # TypeScript类型
│   ├── App.vue
│   └── main.ts
├── fingerprint-chromium/           # 浏览器二进制
│   └── chrome.exe
├── profiles/                       # 配置文件目录
├── package.json
├── vite.config.ts
└── README.md
```

---

## 三、核心模块设计

### 3.1 数据模型

#### Profile (配置文件)

```rust
// src-tauri/src/models/profile.rs

use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Profile {
    /// 唯一ID
    pub id: String,
    /// 显示名称
    pub name: String,
    /// 用户数据目录
    pub data_dir: String,
    /// CDP端口
    pub cdp_port: u16,
    /// 指纹配置
    pub fingerprint: Fingerprint,
    /// 代理设置
    pub proxy: Option<ProxyConfig>,
    /// 启动参数
    pub extra_args: Vec<String>,
    /// 创建时间
    pub created_at: i64,
    /// 更新时间
    pub updated_at: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Fingerprint {
    /// 指纹种子 (核心参数)
    pub seed: i64,
    /// 操作系统
    pub platform: String,           // windows, linux, macos
    /// 浏览器品牌
    pub brand: String,              // Chrome, Edge, etc.
    /// CPU核心数
    pub hardware_concurrency: u8,
    /// 内存大小 (GB)
    pub device_memory: u8,
    /// GPU厂商
    pub gpu_vendor: String,
    /// GPU型号
    pub gpu_renderer: String,
    /// 屏幕宽度
    pub screen_width: u16,
    /// 屏幕高度
    pub screen_height: u16,
    /// 时区
    pub timezone: String,
    /// 语言
    pub language: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProxyConfig {
    /// 代理类型: http, socks5
    pub proxy_type: String,
    /// 代理地址
    pub host: String,
    /// 代理端口
    pub port: u16,
    /// 用户名 (可选)
    pub username: Option<String>,
    /// 密码 (可选)
    pub password: Option<String>,
}

impl Profile {
    pub fn new(name: &str) -> Self {
        let id = Uuid::new_v4().to_string();
        let now = chrono::Utc::now().timestamp();
        
        Self {
            id: id.clone(),
            name: name.to_string(),
            data_dir: format!("profiles/{}", id),
            cdp_port: 0, // 动态分配
            fingerprint: Fingerprint::random(),
            proxy: None,
            extra_args: vec![],
            created_at: now,
            updated_at: now,
        }
    }
}

impl Fingerprint {
    /// 生成随机指纹
    pub fn random() -> Self {
        use rand::Rng;
        let mut rng = rand::thread_rng();
        
        let screens = vec![
            (1920, 1080), (1366, 768), (1440, 900), 
            (1536, 864), (2560, 1440), (1280, 720),
        ];
        let screen = screens[rng.gen_range(0..screens.len())];
        
        let gpus = vec![
            ("Intel Inc.", "Intel Iris OpenGL Engine"),
            ("NVIDIA Corporation", "NVIDIA GeForce GTX 1660"),
            ("NVIDIA Corporation", "NVIDIA GeForce RTX 3060"),
            ("AMD", "AMD Radeon RX 580"),
            ("Google Inc. (NVIDIA)", "ANGLE (NVIDIA GeForce GTX 1060)"),
        ];
        let gpu = gpus[rng.gen_range(0..gpus.len())];
        
        Self {
            seed: rng.gen_range(10000..99999999),
            platform: "windows".to_string(),
            brand: "Chrome".to_string(),
            hardware_concurrency: [4, 8, 12, 16][rng.gen_range(0..4)],
            device_memory: [4, 8, 16, 32][rng.gen_range(0..4)],
            gpu_vendor: gpu.0.to_string(),
            gpu_renderer: gpu.1.to_string(),
            screen_width: screen.0,
            screen_height: screen.1,
            timezone: "Asia/Shanghai".to_string(),
            language: "zh-CN".to_string(),
        }
    }
}
```

#### Device (运行中的设备)

```rust
// src-tauri/src/models/device.rs

use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Device {
    /// 配置文件ID
    pub profile_id: String,
    /// 本地ID
    pub local_id: String,
    /// 服务端分配的设备ID
    pub device_id: Option<String>,
    /// 进程ID
    pub pid: u32,
    /// CDP端口
    pub cdp_port: u16,
    /// 窗口句柄
    pub window_handle: Option<isize>,
    /// 运行状态
    pub status: DeviceStatus,
    /// 窗口是否可见
    pub visible: bool,
    /// WebSocket连接状态
    pub ws_online: bool,
    /// 当前URL
    pub current_url: Option<String>,
    /// 启动时间
    pub started_at: i64,
    /// 最后心跳时间
    pub last_heartbeat: i64,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DeviceStatus {
    Starting,   // 启动中
    Running,    // 运行中
    Stopping,   // 停止中
    Stopped,    // 已停止
    Error,      // 错误
}

impl Device {
    pub fn new(profile_id: &str, pid: u32, cdp_port: u16) -> Self {
        Self {
            profile_id: profile_id.to_string(),
            local_id: format!("local-{}-{}", chrono::Utc::now().timestamp(), pid),
            device_id: None,
            pid,
            cdp_port,
            window_handle: None,
            status: DeviceStatus::Starting,
            visible: true,
            ws_online: false,
            current_url: None,
            started_at: chrono::Utc::now().timestamp(),
            last_heartbeat: chrono::Utc::now().timestamp(),
        }
    }
}
```

### 3.2 浏览器启动器 (ProcessLauncher)

```rust
// src-tauri/src/managers/process_launcher.rs

pub struct ProcessLauncher {
    chromium_path: PathBuf,  // fingerprint-chromium.exe 路径
    instances: HashMap<String, Child>,
}

impl ProcessLauncher {
    /// 启动浏览器实例
    pub fn launch(&mut self, profile: &Profile) -> Result<u32> {
        let args = vec![
            // 核心指纹参数
            format!("--fingerprint={}", profile.fingerprint.seed),
            format!("--fingerprint-platform={}", profile.fingerprint.platform),
            format!("--fingerprint-brand={}", profile.fingerprint.brand),
            
            // 硬件配置
            format!("--fingerprint-hardware-concurrency={}", profile.fingerprint.hardware_concurrency),
            format!("--fingerprint-device-memory={}", profile.fingerprint.device_memory),
            format!("--fingerprint-gpu-vendor={}", profile.fingerprint.gpu_vendor),
            format!("--fingerprint-gpu-renderer={}", profile.fingerprint.gpu_renderer),
            
            // 屏幕和地区
            format!("--window-size={},{}", profile.fingerprint.screen_width, profile.fingerprint.screen_height),
            format!("--timezone={}", profile.fingerprint.timezone),
            format!("--lang={}", profile.fingerprint.language),
            
            // 独立配置目录
            format!("--user-data-dir={}", profile.data_dir),
            
            // CDP 端口
            format!("--remote-debugging-port={}", profile.cdp_port),
            
            // 防检测
            "--disable-blink-features=AutomationControlled".to_string(),
            "--exclude-switches=enable-automation".to_string(),
            "--disable-non-proxied-udp".to_string(),
            "--disable-background-networking".to_string(),
            "--no-first-run".to_string(),
        ];
        
        let child = Command::new(&self.chromium_path)
            .args(&args)
            .spawn()?;
        
        let pid = child.id();
        self.instances.insert(profile.id.clone(), child);
        
        Ok(pid)
    }
    
    /// 批量启动
    pub async fn launch_batch(&mut self, profiles: Vec<Profile>) -> Vec<Result<u32>> {
        let mut results = vec![];
        
        for profile in profiles {
            let result = self.launch(&profile);
            results.push(result);
            
            // 间隔启动避免资源竞争
            tokio::time::sleep(Duration::from_millis(500)).await;
        }
        
        results
    }
    
    /// 停止实例
    pub fn kill(&mut self, profile_id: &str) -> Result<()> {
        if let Some(mut child) = self.instances.remove(profile_id) {
            child.kill()?;
        }
        Ok(())
    }
}
```

### 3.3 CDP管理器

```rust
// src-tauri/src/managers/cdp_manager.rs

use chromiumoxide::{Browser, BrowserConfig, Page};
use futures::StreamExt;
use tokio::sync::RwLock;
use std::collections::HashMap;
use std::sync::Arc;
use anyhow::{Result, anyhow};

pub struct CDPConnection {
    pub browser: Browser,
    pub pages: Vec<Page>,
}

pub struct CDPManager {
    connections: Arc<RwLock<HashMap<String, CDPConnection>>>,
    config: Arc<AppConfig>,
}

impl CDPManager {
    pub fn new(config: Arc<AppConfig>) -> Self {
        Self {
            connections: Arc::new(RwLock::new(HashMap::new())),
            config,
        }
    }

    /// 连接到已启动的浏览器
    pub async fn connect(&mut self, profile_id: &str, cdp_port: u16) -> Result<()> {
        let ws_url = format!("ws://127.0.0.1:{}", cdp_port);
        
        // 等待 CDP 就绪
        for _ in 0..10 {
            if let Ok(browser) = Browser::connect(&ws_url).await {
                let connection = CDPConnection {
                    browser,
                    pages: vec![],
                };
                self.connections.write().await.insert(profile_id.to_string(), connection);
                return Ok(());
            }
            tokio::time::sleep(Duration::from_millis(500)).await;
        }
        
        Err(anyhow::anyhow!("CDP connection timeout"))
    }

    /// 执行JavaScript脚本
    pub async fn execute_script(&self, profile_id: &str, script: &str) -> Result<String> {
        let connections = self.connections.read().await;
        let connection = connections.get(profile_id)
            .ok_or_else(|| anyhow!("Connection not found for {}", profile_id))?;

        let pages = connection.browser.pages().await?;
        let page = pages.first()
            .ok_or_else(|| anyhow!("No page found"))?;

        let result = page.evaluate(script).await?;
        
        Ok(result.to_string())
    }

    /// 在新文档加载前注入脚本
    pub async fn inject_script(&self, profile_id: &str, script: &str) -> Result<()> {
        let connections = self.connections.read().await;
        let connection = connections.get(profile_id)
            .ok_or_else(|| anyhow!("Connection not found for {}", profile_id))?;

        let pages = connection.browser.pages().await?;
        if let Some(page) = pages.first() {
            page.evaluate_on_new_document(script).await?;
        }
        
        Ok(())
    }

    /// 导航到URL
    pub async fn navigate(&self, profile_id: &str, url: &str) -> Result<()> {
        let connections = self.connections.read().await;
        let connection = connections.get(profile_id)
            .ok_or_else(|| anyhow!("Connection not found for {}", profile_id))?;

        let pages = connection.browser.pages().await?;
        if let Some(page) = pages.first() {
            page.goto(url).await?;
        }
        
        Ok(())
    }

    /// 截图
    pub async fn screenshot(&self, profile_id: &str) -> Result<Vec<u8>> {
        let connections = self.connections.read().await;
        let connection = connections.get(profile_id)
            .ok_or_else(|| anyhow!("Connection not found for {}", profile_id))?;

        let pages = connection.browser.pages().await?;
        if let Some(page) = pages.first() {
            let screenshot = page.screenshot(
                chromiumoxide::page::ScreenshotParams::builder()
                    .full_page(false)
                    .build()
            ).await?;
            return Ok(screenshot);
        }
        
        Err(anyhow!("No page found"))
    }

    /// 关闭浏览器
    pub async fn close(&self, profile_id: &str) -> Result<()> {
        let mut connections = self.connections.write().await;
        if let Some(connection) = connections.remove(profile_id) {
            drop(connection);
        }
        Ok(())
    }
}
```

### 3.4 窗口管理器

```rust
// src-tauri/src/managers/window_manager.rs

use windows::Win32::Foundation::{HWND, LPARAM, BOOL, TRUE, FALSE};
use windows::Win32::UI::WindowsAndMessaging::{
    EnumWindows, GetWindowThreadProcessId, ShowWindow, SetWindowPos,
    SW_HIDE, SW_SHOW, SW_MINIMIZE, SW_RESTORE,
    SWP_NOMOVE, SWP_NOSIZE, SWP_NOZORDER,
    HWND_TOP,
};
use tokio::sync::RwLock;
use std::collections::HashMap;
use std::sync::Arc;
use anyhow::{Result, anyhow};

pub struct WindowInfo {
    pub handle: HWND,
    pub pid: u32,
    pub visible: bool,
    pub position: (i32, i32),
    pub size: (i32, i32),
}

pub struct WindowManager {
    windows: Arc<RwLock<HashMap<String, WindowInfo>>>,
}

impl WindowManager {
    pub fn new() -> Self {
        Self {
            windows: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    /// 根据PID查找窗口句柄
    pub fn find_window_by_pid(&self, target_pid: u32) -> Option<HWND> {
        // 枚举窗口实现
        None
    }

    /// 显示窗口
    pub async fn show(&self, profile_id: &str) -> Result<()> {
        let windows = self.windows.read().await;
        if let Some(info) = windows.get(profile_id) {
            unsafe {
                ShowWindow(info.handle, SW_RESTORE);
                ShowWindow(info.handle, SW_SHOW);
            }
            return Ok(());
        }
        Err(anyhow!("Window not found"))
    }

    /// 隐藏窗口
    pub async fn hide(&self, profile_id: &str) -> Result<()> {
        let windows = self.windows.read().await;
        if let Some(info) = windows.get(profile_id) {
            unsafe {
                ShowWindow(info.handle, SW_HIDE);
            }
            return Ok(());
        }
        Err(anyhow!("Window not found"))
    }

    /// 最小化窗口
    pub async fn minimize(&self, profile_id: &str) -> Result<()> {
        let windows = self.windows.read().await;
        if let Some(info) = windows.get(profile_id) {
            unsafe {
                ShowWindow(info.handle, SW_MINIMIZE);
            }
            return Ok(());
        }
        Err(anyhow!("Window not found"))
    }

    /// 设置窗口位置和大小
    pub async fn set_bounds(
        &self, 
        profile_id: &str, 
        x: i32, 
        y: i32, 
        width: i32, 
        height: i32
    ) -> Result<()> {
        let windows = self.windows.read().await;
        if let Some(info) = windows.get(profile_id) {
            unsafe {
                SetWindowPos(
                    info.handle,
                    HWND_TOP,
                    x, y, width, height,
                    SWP_NOZORDER,
                );
            }
            return Ok(());
        }
        Err(anyhow!("Window not found"))
    }

    /// 网格排列所有窗口
    pub async fn arrange_grid(&self, cols: u32, screen_width: u32, screen_height: u32) -> Result<()> {
        let windows = self.windows.read().await;
        let window_list: Vec<_> = windows.values().collect();
        
        let count = window_list.len() as u32;
        if count == 0 {
            return Ok(());
        }

        let rows = (count + cols - 1) / cols;
        let cell_width = screen_width / cols;
        let cell_height = screen_height / rows;

        for (i, info) in window_list.iter().enumerate() {
            let row = i as u32 / cols;
            let col = i as u32 % cols;
            let x = (col * cell_width) as i32;
            let y = (row * cell_height) as i32;

            unsafe {
                ShowWindow(info.handle, SW_RESTORE);
                SetWindowPos(
                    info.handle,
                    HWND_TOP,
                    x, y, cell_width as i32, cell_height as i32,
                    SWP_NOZORDER,
                );
            }
        }

        Ok(())
    }

    /// 隐藏所有窗口
    pub async fn hide_all(&self) -> Result<()> {
        let windows = self.windows.read().await;
        for info in windows.values() {
            unsafe {
                ShowWindow(info.handle, SW_HIDE);
            }
        }
        Ok(())
    }

    /// 显示所有窗口
    pub async fn show_all(&self) -> Result<()> {
        let windows = self.windows.read().await;
        for info in windows.values() {
            unsafe {
                ShowWindow(info.handle, SW_SHOW);
            }
        }
        Ok(())
    }

    /// 注册窗口
    pub async fn register(&self, profile_id: &str, pid: u32) {
        if let Some(handle) = self.find_window_by_pid(pid) {
            let info = WindowInfo {
                handle,
                pid,
                visible: true,
                position: (0, 0),
                size: (1280, 800),
            };
            self.windows.write().await.insert(profile_id.to_string(), info);
        }
    }

    /// 注销窗口
    pub async fn unregister(&self, profile_id: &str) {
        self.windows.write().await.remove(profile_id);
    }
}
```

### 3.5 服务端WebSocket客户端

```rust
// src-tauri/src/managers/server_client.rs

use tokio_tungstenite::{connect_async, tungstenite::Message};
use futures::{StreamExt, SinkExt};
use tokio::sync::{mpsc, RwLock};
use std::sync::Arc;
use anyhow::{Result, anyhow};
use serde::{Deserialize, Serialize};

pub struct ServerClient {
    ws_url: String,
    sender: Arc<RwLock<Option<mpsc::Sender<ClientMessage>>>>,
    connected: Arc<RwLock<bool>>,
}

impl ServerClient {
    pub fn new(ws_url: &str) -> Self {
        Self {
            ws_url: ws_url.to_string(),
            sender: Arc::new(RwLock::new(None)),
            connected: Arc::new(RwLock::new(false)),
        }
    }

    /// 连接到服务端
    pub async fn connect(&self) -> Result<mpsc::Receiver<ServerMessage>> {
        let (ws_stream, _) = connect_async(&self.ws_url).await?;
        let (mut write, mut read) = ws_stream.split();

        let (client_tx, mut client_rx) = mpsc::channel::<ClientMessage>(100);
        let (server_tx, server_rx) = mpsc::channel::<ServerMessage>(100);

        *self.sender.write().await = Some(client_tx);
        *self.connected.write().await = true;

        let connected = self.connected.clone();

        // 发送任务
        tokio::spawn(async move {
            while let Some(msg) = client_rx.recv().await {
                let json = serde_json::to_string(&msg).unwrap();
                if write.send(Message::Text(json)).await.is_err() {
                    break;
                }
            }
        });

        // 接收任务
        tokio::spawn(async move {
            while let Some(Ok(msg)) = read.next().await {
                if let Message::Text(text) = msg {
                    if let Ok(server_msg) = serde_json::from_str::<ServerMessage>(&text) {
                        let _ = server_tx.send(server_msg).await;
                    }
                }
            }
            *connected.write().await = false;
        });

        Ok(server_rx)
    }

    /// 发送消息到服务端
    pub async fn send(&self, msg: ClientMessage) -> Result<()> {
        if let Some(sender) = self.sender.read().await.as_ref() {
            sender.send(msg).await.map_err(|e| anyhow!("Send error: {}", e))?;
        }
        Ok(())
    }

    /// 上报设备状态
    pub async fn report_device_status(&self, device_id: &str, status: &str) -> Result<()> {
        self.send(ClientMessage::DeviceStatus {
            device_id: device_id.to_string(),
            status: status.to_string(),
        }).await
    }

    /// 上报脚本执行结果
    pub async fn report_script_result(&self, task_id: &str, result: &str) -> Result<()> {
        self.send(ClientMessage::ScriptResult {
            task_id: task_id.to_string(),
            result: result.to_string(),
        }).await
    }

    /// 检查连接状态
    pub async fn is_connected(&self) -> bool {
        *self.connected.read().await
    }
}
```

---

## 四、指纹参数配置

fingerprint-chromium 支持的核心参数：

```bash
# 基础指纹
--fingerprint=12345678                           # 指纹种子（核心参数）

# 平台配置
--fingerprint-platform=windows                   # windows/linux/macos
--fingerprint-brand=Chrome                       # Chrome/Edge/Opera

# 硬件配置
--fingerprint-hardware-concurrency=8             # CPU 核心数
--fingerprint-device-memory=16                   # 设备内存 GB
--fingerprint-gpu-vendor="NVIDIA Corporation"    # GPU 厂商
--fingerprint-gpu-renderer="NVIDIA GeForce GTX 1660"  # GPU 型号

# 地区配置
--timezone=Asia/Shanghai                         # 时区
--lang=zh-CN                                     # 语言

# 其他防检测参数
--disable-blink-features=AutomationControlled    # 禁用自动化标记
--exclude-switches=enable-automation             # 移除自动化开关
--disable-non-proxied-udp                        # 禁用非代理 UDP

# 无头模式（可选）
--headless=new                                   # 节省约 40% 内存
```

---

## 五、启动流程

### 5.1 单实例启动流程

```
1. ProfileManager.generate_random()
   ↓ 生成指纹配置
   
2. ProcessLauncher.launch(profile)
   ↓ 启动 fingerprint-chromium
   ↓ 参数: --fingerprint=12345 --remote-debugging-port=9222 ...
   
3. WindowManager.find_window_by_pid(pid)
   ↓ 查找窗口句柄
   
4. CDPManager.connect(profile_id, 9222)
   ↓ 建立 CDP 连接
   
5. ServerClient.report_status("online")
   ↓ 上报设备上线
```

### 5.2 批量启动示例

```rust
pub async fn launch_multiple(count: usize) -> Result<Vec<String>> {
    let mut profile_ids = vec![];
    
    for i in 0..count {
        // 1. 生成配置
        let mut profile = ProfileManager::generate_random();
        profile.cdp_port = 9222 + i as u16;
        profile_manager.save(&profile)?;
        
        // 2. 启动浏览器
        let pid = process_launcher.launch(&profile)?;
        
        // 3. 查找窗口
        window_manager.find_window_by_pid(&profile.id, pid).await?;
        
        // 4. 连接 CDP
        cdp_manager.connect(&profile.id, profile.cdp_port).await?;
        
        // 5. 上报状态
        server_client.report_status(&profile.id, "online").await?;
        
        profile_ids.push(profile.id);
        
        // 间隔启动
        tokio::time::sleep(Duration::from_millis(500)).await;
    }
    
    Ok(profile_ids)
}
```

---

## 六、Tauri Commands

```rust
// src-tauri/src/commands/browser.rs

use tauri::State;
use crate::state::AppState;

/// 启动浏览器
#[tauri::command]
pub async fn start_browser(
    mut profile: Profile,
    state: State<'_, AppState>,
) -> Result<Device, String> {
    state.browser_manager
        .start(&mut profile)
        .await
        .map_err(|e| e.to_string())
}

/// 停止浏览器
#[tauri::command]
pub async fn stop_browser(
    profile_id: String,
    state: State<'_, AppState>,
) -> Result<(), String> {
    state.browser_manager
        .stop(&profile_id)
        .await
        .map_err(|e| e.to_string())
}

/// 获取所有运行中的设备
#[tauri::command]
pub async fn get_devices(
    state: State<'_, AppState>,
) -> Result<Vec<Device>, String> {
    Ok(state.browser_manager.get_all_devices().await)
}

/// 执行脚本
#[tauri::command]
pub async fn execute_script(
    profile_id: String,
    script: String,
    state: State<'_, AppState>,
) -> Result<String, String> {
    state.cdp_manager
        .execute_script(&profile_id, &script)
        .await
        .map_err(|e| e.to_string())
}

/// 导航到URL
#[tauri::command]
pub async fn navigate_to(
    profile_id: String,
    url: String,
    state: State<'_, AppState>,
) -> Result<(), String> {
    state.cdp_manager
        .navigate(&profile_id, &url)
        .await
        .map_err(|e| e.to_string())
}
```

```rust
// src-tauri/src/commands/window.rs

/// 显示窗口
#[tauri::command]
pub async fn show_window(
    profile_id: String,
    state: State<'_, AppState>,
) -> Result<(), String> {
    state.window_manager
        .show(&profile_id)
        .await
        .map_err(|e| e.to_string())
}

/// 隐藏窗口
#[tauri::command]
pub async fn hide_window(
    profile_id: String,
    state: State<'_, AppState>,
) -> Result<(), String> {
    state.window_manager
        .hide(&profile_id)
        .await
        .map_err(|e| e.to_string())
}

/// 排列窗口
#[tauri::command]
pub async fn arrange_windows(
    cols: u32,
    state: State<'_, AppState>,
) -> Result<(), String> {
    state.window_manager
        .arrange_grid(cols, 1920, 1080)
        .await
        .map_err(|e| e.to_string())
}

/// 隐藏所有窗口
#[tauri::command]
pub async fn hide_all_windows(
    state: State<'_, AppState>,
) -> Result<(), String> {
    state.window_manager
        .hide_all()
        .await
        .map_err(|e| e.to_string())
}

/// 显示所有窗口
#[tauri::command]
pub async fn show_all_windows(
    state: State<'_, AppState>,
) -> Result<(), String> {
    state.window_manager
        .show_all()
        .await
        .map_err(|e| e.to_string())
}
```

---

## 七、前端代码

### 7.1 TypeScript类型定义

```typescript
// src/types/index.ts

export interface Fingerprint {
  seed: number;
  platform: string;
  brand: string;
  hardware_concurrency: number;
  device_memory: number;
  gpu_vendor: string;
  gpu_renderer: string;
  screen_width: number;
  screen_height: number;
  timezone: string;
  language: string;
}

export interface ProxyConfig {
  proxy_type: string;
  host: string;
  port: number;
  username?: string;
  password?: string;
}

export interface Profile {
  id: string;
  name: string;
  data_dir: string;
  cdp_port: number;
  fingerprint: Fingerprint;
  proxy?: ProxyConfig;
  extra_args: string[];
  created_at: number;
  updated_at: number;
}

export type DeviceStatus = 'Starting' | 'Running' | 'Stopping' | 'Stopped' | 'Error';

export interface Device {
  profile_id: string;
  local_id: string;
  device_id?: string;
  pid: number;
  cdp_port: number;
  window_handle?: number;
  status: DeviceStatus;
  visible: boolean;
  ws_online: boolean;
  current_url?: string;
  started_at: number;
  last_heartbeat: number;
}
```

### 7.2 API封装

```typescript
// src/api/browser.ts

import { invoke } from '@tauri-apps/api/tauri';
import type { Profile, Device } from '@/types';

export const browserApi = {
  async start(profile: Profile): Promise<Device> {
    return invoke('start_browser', { profile });
  },

  async stop(profileId: string): Promise<void> {
    return invoke('stop_browser', { profileId });
  },

  async getDevices(): Promise<Device[]> {
    return invoke('get_devices');
  },

  async executeScript(profileId: string, script: string): Promise<string> {
    return invoke('execute_script', { profileId, script });
  },

  async navigateTo(profileId: string, url: string): Promise<void> {
    return invoke('navigate_to', { profileId, url });
  },

  async screenshot(profileId: string): Promise<Uint8Array> {
    return invoke('take_screenshot', { profileId });
  },
};

export const windowApi = {
  async show(profileId: string): Promise<void> {
    return invoke('show_window', { profileId });
  },

  async hide(profileId: string): Promise<void> {
    return invoke('hide_window', { profileId });
  },

  async arrange(cols: number): Promise<void> {
    return invoke('arrange_windows', { cols });
  },

  async hideAll(): Promise<void> {
    return invoke('hide_all_windows');
  },

  async showAll(): Promise<void> {
    return invoke('show_all_windows');
  },
};
```

---

## 八、配置文件

### 8.1 Cargo.toml

```toml
[package]
name = "browser-manager"
version = "0.1.0"
edition = "2021"

[dependencies]
# Tauri
tauri = { version = "2.0", features = ["shell-open"] }
tauri-plugin-shell = "2.0"

# 异步运行时
tokio = { version = "1", features = ["full"] }
futures = "0.3"

# CDP
chromiumoxide = { version = "0.7", features = ["tokio-runtime"] }

# WebSocket
tokio-tungstenite = { version = "0.21", features = ["native-tls"] }

# 序列化
serde = { version = "1", features = ["derive"] }
serde_json = "1"

# Windows API
[target.'cfg(windows)'.dependencies]
windows = { version = "0.52", features = [
    "Win32_Foundation",
    "Win32_UI_WindowsAndMessaging",
    "Win32_System_Threading",
]}

# 工具库
anyhow = "1"
thiserror = "1"
tracing = "0.1"
tracing-subscriber = "0.3"
uuid = { version = "1", features = ["v4"] }
chrono = "0.4"
rand = "0.8"
dirs = "5"

[build-dependencies]
tauri-build = "2.0"

[profile.release]
lto = true
codegen-units = 1
strip = true
```

### 8.2 tauri.conf.json

```json
{
  "$schema": "https://schema.tauri.app/config/2.0.0",
  "productName": "Browser Manager",
  "version": "0.1.0",
  "identifier": "com.browser-manager.app",
  "build": {
    "beforeDevCommand": "npm run dev",
    "devUrl": "http://localhost:5173",
    "beforeBuildCommand": "npm run build",
    "frontendDist": "../dist"
  },
  "app": {
    "windows": [
      {
        "title": "浏览器多开管理器",
        "width": 1280,
        "height": 800,
        "resizable": true,
        "fullscreen": false
      }
    ],
    "security": {
      "csp": null
    }
  },
  "bundle": {
    "active": true,
    "targets": "all",
    "icon": [
      "icons/32x32.png",
      "icons/128x128.png",
      "icons/128x128@2x.png",
      "icons/icon.icns",
      "icons/icon.ico"
    ],
    "windows": {
      "wix": {
        "language": "zh-CN"
      }
    }
  }
}
```

---

## 九、与 Go 服务端通信协议

### 9.1 消息格式

```typescript
// 客户端 → 服务端
interface ClientMessage {
  type: 'device_hello' | 'device_status' | 'script_result' | 'heartbeat';
  payload: any;
}

// 服务端 → 客户端
interface ServerMessage {
  type: 'execute_script' | 'navigate' | 'config_update' | 'task_assign';
  payload: any;
}
```

### 9.2 示例消息

```json
// 设备上线
{
  "type": "device_hello",
  "payload": {
    "local_id": "local-1706000000-12345",
    "profile_id": "uuid-xxx",
    "fingerprint": { ... }
  }
}

// 执行脚本
{
  "type": "execute_script",
  "payload": {
    "task_id": "task-001",
    "device_id": "device-xxx",
    "script": "document.title"
  }
}

// 脚本结果
{
  "type": "script_result",
  "payload": {
    "task_id": "task-001",
    "result": "Google",
    "success": true
  }
}
```

---

## 十、开发计划

### Week 1: 基础框架

- [x] 下载 fingerprint-chromium 预编译版本
- [x] 创建 Rust + Tauri 项目
- [x] 实现 ProfileManager (指纹配置生成)
- [x] 实现 ProcessLauncher (浏览器启动)
- [x] 测试单实例启动
- [x] 创建基础 UI 界面

### Week 2: 核心功能

- [ ] 实现 CDPManager (CDP 连接和控制)
- [ ] 实现 WindowManager (窗口显示/隐藏/排列)
- [ ] 实现批量启动逻辑
- [ ] 实现 Profile 持久化存储
- [ ] UI 完善：实例列表、控制面板

### Week 3: 服务端对接

- [ ] 实现 ServerClient (WebSocket 客户端)
- [ ] 对接 Go 服务端通信协议
- [ ] 实现脚本执行指令
- [ ] 实现状态上报
- [ ] 异常处理和重连机制

### Week 4: 测试和优化

- [ ] 指纹检测测试 (creepjs, pixelscan, browserleaks)
- [ ] 多实例压力测试
- [ ] 内存和性能优化
- [ ] 错误处理完善
- [ ] 打包和发布

---

## 十一、打包发布

### 11.1 打包命令

```bash
# 开发构建
npm run tauri dev

# 生产构建
npm run tauri build

# 输出目录
# Windows: src-tauri/target/release/bundle/msi/
# 或: src-tauri/target/release/browser-manager.exe
```

### 11.2 预期打包大小

| 组件 | 大小 |
|------|------|
| Tauri EXE | ~3-5MB |
| fingerprint-chromium | ~150MB |
| 总计 | ~155MB |

对比 Electron 方案约 200-300MB，Tauri 方案显著更小。

---

## 十二、环境准备

```bash
# 1. 安装 Rust
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# 2. 安装 Node.js (v18+)
# 下载: https://nodejs.org/

# 3. 安装 Tauri CLI
cargo install tauri-cli

# 4. 下载 fingerprint-chromium
# https://github.com/adryfish/fingerprint-chromium/releases
# 或 https://pan.quark.cn/s/9bb65af874fb
# 解压到项目 browsers/ 目录

# 5. 创建项目
npm create tauri-app@latest browser-manager -- --template vue-ts

cd browser-manager

# 6. 安装前端依赖
npm install
npm install element-plus @element-plus/icons-vue pinia

# 7. 运行开发环境
npm run tauri dev
```

---

## 十三、风险和局限

### 潜在风险

1. **依赖外部项目**
   - fingerprint-chromium 停止维护
   - 缓解：可切换到其他预编译版本（如 BotBrowser）

2. **版本更新滞后**
   - 当前最新版本可能落后官方 Chrome
   - 缓解：定期检查更新，多数场景无影响

3. **定制能力受限**
   - 无法修改 Chromium 源码
   - 缓解：大部分需求通过 CDP 和启动参数满足

### 不适合场景

- ❌ 需要极度定制的指纹修改逻辑
- ❌ 需要修改 Chromium 内核行为
- ❌ 需要最新版 Chrome 特性

### 适合场景

- ✅ 快速落地产品
- ✅ 标准的反指纹需求
- ✅ 多开浏览器管理
- ✅ 自动化脚本执行
- ✅ 中小规模部署

---

## 十四、总结

### 技术优势

| 优势 | 说明 |
|------|------|
| **极小打包体积** | ~5MB vs Electron ~200MB |
| **低内存占用** | 管理器仅 ~20MB |
| **高性能** | Rust 原生性能 |
| **类型安全** | Rust + TypeScript 双重保障 |
| **原生窗口控制** | windows-rs 直接调用 Win32 API |
| **异步并发** | Tokio 高性能异步运行时 |

### 完整技术栈

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                           完整技术栈                                            │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│  前端: Vue 3 + TypeScript + Element Plus + Pinia                               │
│                                                                                 │
│  后端: Rust + Tauri 2.0 + Tokio                                                │
│                                                                                 │
│  CDP控制: chromiumoxide                                                         │
│                                                                                 │
│  窗口控制: windows-rs (Win32 API)                                               │
│                                                                                 │
│  通信: tokio-tungstenite (WebSocket)                                           │
│                                                                                 │
│  浏览器: fingerprint-chromium (预编译版)                                        │
│                                                                                 │
│  服务端: Go + gorilla/websocket (已有)                                         │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### 下一步行动

1. **下载 fingerprint-chromium** 预编译版本
2. **创建 Tauri 项目** 按照上述结构
3. **实现核心模块** 按照阶段计划
4. **对接 Go 服务端** WebSocket 通信
5. **测试指纹隔离** 在检测网站验证

---

## 参考资料

- Tauri 文档: https://tauri.app/
- chromiumoxide 文档: https://docs.rs/chromiumoxide
- fingerprint-chromium: https://github.com/adryfish/fingerprint-chromium
- fingerprint-chromium 备用下载: https://pan.quark.cn/s/9bb65af874fb
