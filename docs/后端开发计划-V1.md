# 后端开发计划与步骤（V1）

## 目标

后端形成稳定可控的进程/窗口管理，并提供状态事件与设置校验，确保 UI 不漂移。

---

## 当前开发进度（代码审计结果）

审计范围：

- `src-tauri/src/lib.rs`（IPC 命令注册与主流程）
- `src-tauri/src/modules/settings.rs`（设置校验）
- `src-tauri/src/modules/profile/*`（Profile CRUD）
- `src-tauri/src/modules/browser_manager.rs`（进程生命周期与事件）
- `src-tauri/src/modules/browser/launcher.rs`（启动器）

### 结论（当前可用度）

- **总体完成度（后端侧）**：约 **70%-80%（偏 75%）**
- **可联调主链路（基本可用）**：Settings/Profile/启动停止/窗口群控命令已具备
- **V1 阻塞缺口（必须补齐）**：
  - **Group（分组）IPC 与服务端实现缺失**：当前后端未注册 `get_groups/create_group/update_group/delete_group` 等命令
  - **Fingerprint “子集 + 透传（受控）”缺失**：目前 Profile 更新会直接覆盖 fingerprint JSON，未实现白名单 patch merge 与黑名单防注入

### 已实现（与计划对照）

- **BE-0 接口冻结/命令对齐**：核心 Profile/Browser/Settings/Window 命令已在 `lib.rs` 注册
- **BE-1.1 kernel_path 校验**：已实现（`validate_kernel_path`），错误信息可直接展示
- **BE-1.2 user_data_dir 校验**：已实现（`validate_user_data_dir`）
- **Profile CRUD（ProfileService）**：已实现 create/get/list/update/delete/status 更新
- **Browser 启动/停止与限流**：已实现（通过 `BrowserManager` 的 `Semaphore` 获取 permit），并具备“重复启动幂等”逻辑
- **Window 群控（grid/hide/show）**：已实现（基于 BrowserManager 的运行 PID 列表）

### 进行中 / 部分完成

- **BE-1.3 启动限流/队列**：已具备“启动限流（Semaphore）”，但批量启动目前为顺序执行（`batch_launch_browsers` 逐个 await），未实现“并发启动 + 错误收集”
- **BE-2.1 进程表完善**：已实现 `ProcessInfo`/`ProcessStatus` 基础结构，但
  - `unregister_process` 当前直接 `remove` 记录，不保留 `Stopping/Stopped` 状态历史
  - `Starting` 状态在启动前未写入（目前是在启动完成后直接写入 Running）
- **BE-2.2 事件推送**：已实现并在关键路径发出
  - `profile:status_changed`
  - `browser:error`
  但事件命名/事件集合与文档中的“browser_started/browser_stopped”等尚未统一（建议以 `profile:status_changed` 为主统一）
- **BE-2.3 异常回收**：已实现后台 `start_process_monitor`（5 秒轮询）检测退出、更新 DB、发事件；但对“异常退出原因”与更精细的僵尸清理策略仍较弱

### 未实现 / 风险点（V1 需明确处理）

- **Group（分组）后端模块缺失**：前端 V1 已纳入 Group CRUD 与“禁止删除非空分组”，后端需补齐：
  - groups 表结构（若未存在）
  - GroupService（CRUD）
  - IPC commands：`get_groups/get_group/create_group/update_group/delete_group`
  - 返回字段 `profile_count`（用于前端禁止删除非空分组）
- **删除分组策略（禁止删除非空）后端校验**：前端会拦截，但后端也应校验（防绕过）
- **Fingerprint “子集 + 透传（受控）”**：当前后端逻辑为“写入即覆盖”。V1 需实现：
  - 白名单字段 patch（只允许写入指定键）
  - 黑名单剔除/拒绝（禁止注入启动参数/路径/调试端口等危险键）
  - existing + patch merge（透传不丢）
- **稳定性风险**：
  - Window 群控目前未做主窗口过滤/重试/延迟，可能误操作 DevTools 或找不到窗口
  - `BrowserLauncher` 固定设置 `--remote-debugging-port=0`，后续若引入 CDP/端口管理需明确策略（端口应后端掌控且不允许前端透传）

### 近期建议的“依赖关口”（联调 Gate）

- **Gate-BE-Group**：Group IPC/服务/DB 先齐，前端才能按计划交付 Group 管理
- **Gate-BE-FP**：Fingerprint merge（子集 + 透传）落地，否则前端的“透传不丢”验收无法成立
- **Gate-BE-Batch**：批量接口失败语义明确（失败即中断 vs 收集错误继续），否则前端无法做准确反馈

### 任务状态总览（按当前代码）

| 模块/任务 | 计划阶段 | 当前状态 | 备注 |
|---|---|---|---|
| IPC 命令对齐（Profile/Settings/Browser/Window） | BE-0 | 已完成 | `lib.rs` 已注册核心命令 |
| Settings 校验（kernel_path/user_data_dir） | BE-1.1/1.2 | 已完成 | `modules/settings.rs` 含单测 |
| Profile CRUD（含 update_profile SQL 可靠性） | BE-1/BE-0 | 已完成 | `ProfileService` 可用 |
| Browser 启动/停止 + 幂等 | BE-2/BE-1 | 已完成 | `BrowserManager.is_running` + DB status 更新 |
| 启动限流（Semaphore） | BE-1.3 | 部分完成 | 已限流，但批量仍顺序执行 |
| 事件推送（status_changed/browser:error） | BE-2.2 | 已完成 | 事件命名需与文档统一 |
| 异常回收（后台监控进程退出） | BE-2.3 | 部分完成 | 已轮询退出并更新 DB/发事件 |
| 窗口群控稳定性增强（主窗口过滤/重试） | BE-3.1 | 未开始 | 当前仅按 PID 枚举 HWND，无过滤重试 |
| Group（分组）CRUD + profile_count + 删除限制（禁止删除非空） | 新增（V1 必须） | 未开始 | 后端未实现 groups 模块与 IPC |
| Fingerprint：子集 + 透传（受控，白/黑名单 + merge） | 新增（V1 必须） | 未开始 | 当前 update_profile 直接覆盖 fingerprint |

---

## Phase BE-0：接口冻结与兼容（0.5-1 天）

### [任务 0.1] IPC 命令清点与冻结

**目标：** 以 `docs/IPC-接口说明.md` 为准，确认命令名/参数名不再改（特别是 `profileId`/`profileIds`）

**具体步骤：**

1. **清点现有命令**
   - 检查 `src-tauri/src/lib.rs` 中所有 `#[tauri::command]` 函数
   - 与 `docs/IPC-接口说明.md` 逐一对照
   - 列出不一致的地方

2. **参数名统一**
   ```rust
   // ✅ 正确：使用 camelCase
   #[tauri::command]
   async fn launch_browser(profile_id: String) -> Result<(), String>
   
   // ❌ 错误：参数名不一致
   #[tauri::command]
   async fn launch_browser(id: String) -> Result<(), String>
   ```

3. **命令名冻结**
   - 确认以下核心命令名不再变更：
     - Profile: `get_profiles`, `get_profile`, `create_profile`, `update_profile`, `delete_profile`, `batch_delete_profiles`
     - Browser: `launch_browser`, `stop_browser`, `batch_launch_browsers`, `batch_stop_browsers`
     - Settings: `get_setting_value`, `set_setting_value`, `get_all_settings`
     - Window: `arrange_windows_grid`, `hide_all_windows`, `show_all_windows`

4. **文档更新流程**
   - 新增命令必须先在 `docs/IPC-接口说明.md` 中添加
   - 包含：命令名、参数、返回值、错误处理、示例代码
   - Code Review 时检查文档是否同步

**验收标准：**
- ✅ 接口文档与 `lib.rs` 完全一致
- ✅ 所有参数名使用 camelCase（前端调用时）
- ✅ 新增命令有完整文档

**预计时间：** 0.5 天

---

## Phase BE-1：设置校验与启动稳定性（2-3 天）

### [任务 1.1] kernel_path 校验

**目标：** 确保浏览器内核路径有效且可执行

**具体步骤：**

1. **创建校验函数**
   ```rust
   // src-tauri/src/modules/settings.rs
   
   fn validate_kernel_path(path: &str) -> Result<(), String> {
       let path_obj = std::path::Path::new(path);
       
       // 检查路径是否存在
       if !path_obj.exists() {
           return Err(format!("内核路径不存在: {}", path));
       }
       
       // 检查是否为文件
       if !path_obj.is_file() {
           return Err(format!("内核路径不是文件: {}", path));
       }
       
       // Windows 平台检查 .exe 扩展名
       #[cfg(target_os = "windows")]
       {
           if path_obj.extension().and_then(|s| s.to_str()) != Some("exe") {
               return Err("内核文件必须是 .exe 可执行文件".to_string());
           }
       }
       
       // 检查文件是否可执行（Unix 系统）
       #[cfg(unix)]
       {
           use std::os::unix::fs::PermissionsExt;
           let metadata = path_obj.metadata()
               .map_err(|e| format!("无法读取文件权限: {}", e))?;
           let permissions = metadata.permissions();
           if permissions.mode() & 0o111 == 0 {
               return Err("文件没有执行权限".to_string());
           }
       }
       
       Ok(())
   }
   ```

2. **集成到 set_setting_value**
   ```rust
   #[tauri::command]
   async fn set_setting_value(
       key: String,
       value: String,
       state: State<'_, AppState>
   ) -> Result<(), String> {
       // 特殊键值校验
       match key.as_str() {
           "kernel_path" => {
               validate_kernel_path(&value)?;
           },
           "user_data_dir" => {
               validate_user_data_dir(&value)?;
           },
           _ => {}
       }
       
       // 保存到数据库
       sqlx::query!(
           "INSERT OR REPLACE INTO settings (key, value) VALUES (?, ?)",
           key,
           value
       )
       .execute(&state.pool)
       .await
       .map_err(|e| format!("保存设置失败: {}", e))?;
       
       Ok(())
   }
   ```

3. **错误信息优化**
   - 错误信息要具体、可操作
   - 前端可以直接展示给用户
   - 避免技术术语，使用用户友好的语言

**验收标准：**
- ✅ 路径不存在时返回明确错误
- ✅ 非可执行文件时返回明确错误
- ✅ 错误信息前端可直接展示
- ✅ 单元测试覆盖所有校验分支

**预计时间：** 0.5 天

---

### [任务 1.2] user_data_dir 校验

**目标：** 确保用户数据目录可创建/可写，为每个 profile 创建独立目录

**具体步骤：**

1. **创建校验函数**
   ```rust
   fn validate_user_data_dir(path: &str) -> Result<(), String> {
       let path_obj = std::path::Path::new(path);
       
       // 如果目录不存在，尝试创建
       if !path_obj.exists() {
           std::fs::create_dir_all(path_obj)
               .map_err(|e| format!("无法创建用户数据目录: {}", e))?;
       }
       
       // 检查是否为目录
       if !path_obj.is_dir() {
           return Err("用户数据路径必须是目录".to_string());
       }
       
       // 测试写入权限
       let test_file = path_obj.join(".write_test");
       std::fs::write(&test_file, "test")
           .map_err(|e| format!("用户数据目录不可写: {}", e))?;
       std::fs::remove_file(&test_file).ok();
       
       Ok(())
   }
   ```

2. **为每个 Profile 创建独立目录**
   ```rust
   fn get_profile_data_dir(
       base_dir: &str,
       profile_id: &str
   ) -> Result<PathBuf, String> {
       let profile_dir = Path::new(base_dir).join(profile_id);
       
       if !profile_dir.exists() {
           std::fs::create_dir_all(&profile_dir)
               .map_err(|e| format!("创建 Profile 数据目录失败: {}", e))?;
       }
       
       Ok(profile_dir)
   }
   ```

3. **启动时使用独立目录**
   ```rust
   async fn do_launch_browser(
       profile_id: String,
       state: &AppState
   ) -> Result<(), String> {
       // 获取设置
       let kernel_path = get_setting_value("kernel_path", state).await?;
       let base_data_dir = get_setting_value("user_data_dir", state).await?;
       
       // 为此 profile 创建独立目录
       let profile_data_dir = get_profile_data_dir(&base_data_dir, &profile_id)?;
       
       // 启动浏览器
       let mut cmd = Command::new(&kernel_path);
       cmd.arg(format!("--user-data-dir={}", profile_data_dir.display()));
       // ... 其他参数
   }
   ```

**验收标准：**
- ✅ 目录不存在时自动创建
- ✅ 目录不可写时返回明确错误
- ✅ 每个 profile 有独立的数据目录
- ✅ 目录命名规范（使用 profile_id）

**预计时间：** 0.5 天

---

### [任务 1.3] 启动限流/队列（防止批量启动卡死）

**目标：** 批量启动 N=10 时系统不假死，失败可恢复

**具体步骤：**

1. **创建启动队列**
   ```rust
   use tokio::sync::Semaphore;
   use std::sync::Arc;
   
   pub struct BrowserManager {
       processes: Arc<Mutex<HashMap<String, Child>>>,
       // 限制同时启动的浏览器数量
       launch_semaphore: Arc<Semaphore>,
   }
   
   impl BrowserManager {
       pub fn new() -> Self {
           Self {
               processes: Arc::new(Mutex::new(HashMap::new())),
               // 最多同时启动 3 个浏览器
               launch_semaphore: Arc::new(Semaphore::new(3)),
           }
       }
   }
   ```

2. **实现限流启动**
   ```rust
   async fn launch_with_limit(
       &self,
       profile_id: String,
       state: &AppState
   ) -> Result<(), String> {
       // 获取信号量许可
       let _permit = self.launch_semaphore
           .acquire()
           .await
           .map_err(|e| format!("获取启动许可失败: {}", e))?;
       
       // 实际启动逻辑
       self.do_launch(profile_id, state).await?;
       
       // permit 自动释放
       Ok(())
   }
   ```

3. **批量启动优化**
   ```rust
   #[tauri::command]
   async fn batch_launch_browsers(
       profile_ids: Vec<String>,
       state: State<'_, AppState>
   ) -> Result<(), String> {
       let manager = &state.browser_manager;
       
       // 并发启动，但受信号量限制
       let tasks: Vec<_> = profile_ids
           .into_iter()
           .map(|id| {
               let manager = manager.clone();
               let state = state.inner().clone();
               tokio::spawn(async move {
                   manager.launch_with_limit(id.clone(), &state).await
               })
           })
           .collect();
       
       // 等待所有任务完成
       let results = futures::future::join_all(tasks).await;
       
       // 收集错误
       let errors: Vec<_> = results
           .into_iter()
           .filter_map(|r| r.err())
           .collect();
       
       if !errors.is_empty() {
           return Err(format!("部分启动失败: {:?}", errors));
       }
       
       Ok(())
   }
   ```

4. **添加启动延迟**
   ```rust
   async fn do_launch(&self, profile_id: String, state: &AppState) -> Result<(), String> {
       // 启动前短暂延迟，避免资源竞争
       tokio::time::sleep(Duration::from_millis(100)).await;
       
       // 实际启动逻辑
       // ...
   }
   ```

**验收标准：**
- ✅ 批量启动 10 个窗口时系统响应正常
- ✅ 启动失败不影响其他窗口
- ✅ 可配置最大并发数
- ✅ 有启动进度反馈

**预计时间：** 1-1.5 天

---

## Phase BE-2：进程生命周期与状态事件（2-4 天）

### [任务 2.1] BrowserManager 进程表完善

**目标：** 维护 profile_id -> pid/状态/启动时间，防重复启动、stop 幂等

**具体步骤：**

1. **完善进程信息结构**
   ```rust
   #[derive(Debug, Clone)]
   pub struct ProcessInfo {
       pub profile_id: String,
       pub pid: u32,
       pub status: ProcessStatus,
       pub started_at: DateTime<Utc>,
       pub child: Option<Child>,
   }
   
   #[derive(Debug, Clone, PartialEq)]
   pub enum ProcessStatus {
       Starting,
       Running,
       Stopping,
       Stopped,
       Error(String),
   }
   
   pub struct BrowserManager {
       processes: Arc<Mutex<HashMap<String, ProcessInfo>>>,
       launch_semaphore: Arc<Semaphore>,
   }
   ```

2. **防重复启动**
   ```rust
   async fn launch(&self, profile_id: String, state: &AppState) -> Result<(), String> {
       // 检查是否已在运行
       {
           let processes = self.processes.lock().await;
           if let Some(info) = processes.get(&profile_id) {
               match info.status {
                   ProcessStatus::Running | ProcessStatus::Starting => {
                       return Err(format!("窗口 {} 已在运行中", profile_id));
                   }
                   _ => {}
               }
           }
       }
       
       // 标记为启动中
       {
           let mut processes = self.processes.lock().await;
           processes.insert(profile_id.clone(), ProcessInfo {
               profile_id: profile_id.clone(),
               pid: 0,
               status: ProcessStatus::Starting,
               started_at: Utc::now(),
               child: None,
           });
       }
       
       // 实际启动
       match self.do_launch(&profile_id, state).await {
           Ok(child) => {
               let pid = child.id();
               let mut processes = self.processes.lock().await;
               processes.insert(profile_id.clone(), ProcessInfo {
                   profile_id: profile_id.clone(),
                   pid,
                   status: ProcessStatus::Running,
                   started_at: Utc::now(),
                   child: Some(child),
               });
               Ok(())
           }
           Err(e) => {
               let mut processes = self.processes.lock().await;
               processes.insert(profile_id.clone(), ProcessInfo {
                   profile_id: profile_id.clone(),
                   pid: 0,
                   status: ProcessStatus::Error(e.clone()),
                   started_at: Utc::now(),
                   child: None,
               });
               Err(e)
           }
       }
   }
   ```

3. **Stop 幂等性**
   ```rust
   async fn stop(&self, profile_id: &str) -> Result<(), String> {
       let mut processes = self.processes.lock().await;
       
       let info = processes.get_mut(profile_id)
           .ok_or_else(|| format!("窗口 {} 未运行", profile_id))?;
       
       // 如果已经停止，直接返回成功
       match info.status {
           ProcessStatus::Stopped => {
               return Ok(());
           }
           ProcessStatus::Stopping => {
               return Ok(()); // 正在停止中
           }
           _ => {}
       }
       
       // 标记为停止中
       info.status = ProcessStatus::Stopping;
       
       // 获取 child
       let mut child = info.child.take()
           .ok_or_else(|| "进程句柄丢失".to_string())?;
       
       // 释放锁后再 kill
       drop(processes);
       
       // 尝试优雅关闭
       child.kill().map_err(|e| format!("停止进程失败: {}", e))?;
       child.wait().map_err(|e| format!("等待进程退出失败: {}", e))?;
       
       // 更新状态
       let mut processes = self.processes.lock().await;
       if let Some(info) = processes.get_mut(profile_id) {
           info.status = ProcessStatus::Stopped;
           info.child = None;
       }
       
       Ok(())
   }
   ```

**验收标准：**
- ✅ 同一 profile 不能重复启动
- ✅ stop 可以多次调用不报错
- ✅ 进程信息准确（pid、状态、启动时间）
- ✅ 内存泄漏测试通过

**预计时间：** 1 天

---

### [任务 2.2] 事件推送（关键）

**目标：** 实现 `profile_status_changed` / `browser_started` / `browser_stopped` / `browser_error` 事件

**具体步骤：**

1. **定义事件类型**
   ```rust
   use serde::Serialize;
   
   #[derive(Debug, Clone, Serialize)]
   pub struct ProfileStatusChangedEvent {
       pub profile_id: String,
       pub status: String, // "running" | "stopped" | "error"
       pub timestamp: i64,
   }
   
   #[derive(Debug, Clone, Serialize)]
   pub struct BrowserErrorEvent {
       pub profile_id: String,
       pub error: String,
       pub timestamp: i64,
   }
   ```

2. **创建事件发射器**
   ```rust
   use tauri::Manager;
   
   pub struct EventEmitter {
       app_handle: tauri::AppHandle,
   }
   
   impl EventEmitter {
       pub fn new(app_handle: tauri::AppHandle) -> Self {
           Self { app_handle }
       }
       
       pub fn emit_status_changed(&self, profile_id: String, status: &str) {
           let event = ProfileStatusChangedEvent {
               profile_id,
               status: status.to_string(),
               timestamp: Utc::now().timestamp_millis(),
           };
           
           self.app_handle
               .emit_all("profile:status_changed", event)
               .ok();
       }
       
       pub fn emit_browser_error(&self, profile_id: String, error: String) {
           let event = BrowserErrorEvent {
               profile_id,
               error,
               timestamp: Utc::now().timestamp_millis(),
           };
           
           self.app_handle
               .emit_all("browser:error", event)
               .ok();
       }
   }
   ```

3. **集成到 BrowserManager**
   ```rust
   pub struct BrowserManager {
       processes: Arc<Mutex<HashMap<String, ProcessInfo>>>,
       launch_semaphore: Arc<Semaphore>,
       event_emitter: Arc<EventEmitter>,
   }
   
   impl BrowserManager {
       async fn launch(&self, profile_id: String, state: &AppState) -> Result<(), String> {
           // ... 启动逻辑 ...
           
           // 启动成功后发送事件
           self.event_emitter.emit_status_changed(profile_id.clone(), "running");
           
           Ok(())
       }
       
       async fn stop(&self, profile_id: &str) -> Result<(), String> {
           // ... 停止逻辑 ...
           
           // 停止成功后发送事件
           self.event_emitter.emit_status_changed(profile_id.to_string(), "stopped");
           
           Ok(())
       }
   }
   ```

4. **后台监控任务**
   ```rust
   pub async fn start_process_monitor(
       manager: Arc<BrowserManager>,
       interval: Duration
   ) {
       tokio::spawn(async move {
           loop {
               tokio::time::sleep(interval).await;
               
               let mut processes = manager.processes.lock().await;
               let mut to_remove = Vec::new();
               
               for (profile_id, info) in processes.iter_mut() {
                   if let Some(child) = &mut info.child {
                       // 检查进程是否退出
                       match child.try_wait() {
                           Ok(Some(status)) => {
                               // 进程已退出
                               info.status = ProcessStatus::Stopped;
                               info.child = None;
                               
                               manager.event_emitter.emit_status_changed(
                                   profile_id.clone(),
                                   "stopped"
                               );
                               
                               to_remove.push(profile_id.clone());
                           }
                           Ok(None) => {
                               // 进程仍在运行
                           }
                           Err(e) => {
                               // 检查失败
                               eprintln!("检查进程状态失败: {}", e);
                           }
                       }
                   }
               }
               
               // 清理已退出的进程
               for profile_id in to_remove {
                   processes.remove(&profile_id);
               }
           }
       });
   }
   ```

**验收标准：**
- ✅ 前端订阅后能实时收到状态变化
- ✅ 手动关闭浏览器后前端状态自动更新
- ✅ 崩溃时能检测到并通知前端
- ✅ 事件包含完整信息（profile_id、status、timestamp）

**预计时间：** 1.5-2 天

---

### [任务 2.3] 异常回收

**目标：** Child 退出检测（后台任务 wait），退出后从 processes 移除并更新 DB 状态

**具体步骤：**

1. **进程退出监听**
   ```rust
   async fn spawn_exit_watcher(
       profile_id: String,
       mut child: Child,
       manager: Arc<BrowserManager>,
       pool: Arc<SqlitePool>
   ) {
       tokio::spawn(async move {
           // 等待进程退出
           match child.wait().await {
               Ok(status) => {
                   println!("进程 {} 退出，状态码: {:?}", profile_id, status.code());
                   
                   // 更新内存状态
                   {
                       let mut processes = manager.processes.lock().await;
                       if let Some(info) = processes.get_mut(&profile_id) {
                           info.status = ProcessStatus::Stopped;
                           info.child = None;
                       }
                   }
                   
                   // 更新数据库状态
                   sqlx::query!(
                       "UPDATE profiles SET status = 'stopped' WHERE id = ?",
                       profile_id
                   )
                   .execute(&*pool)
                   .await
                   .ok();
                   
                   // 发送事件
                   manager.event_emitter.emit_status_changed(profile_id, "stopped");
               }
               Err(e) => {
                   eprintln!("等待进程退出失败: {}", e);
                   
                   // 标记为错误状态
                   manager.event_emitter.emit_browser_error(
                       profile_id.clone(),
                       format!("进程异常退出: {}", e)
                   );
               }
           }
       });
   }
   ```

2. **启动时注册监听**
   ```rust
   async fn launch(&self, profile_id: String, state: &AppState) -> Result<(), String> {
       // ... 启动逻辑 ...
       
       let child = self.do_launch(&profile_id, state).await?;
       
       // 注册退出监听
       spawn_exit_watcher(
           profile_id.clone(),
           child,
           Arc::clone(&self),
           Arc::clone(&state.pool)
       );
       
       Ok(())
   }
   ```

3. **定期清理僵尸进程**
   ```rust
   pub async fn start_zombie_cleaner(
       manager: Arc<BrowserManager>,
       interval: Duration
   ) {
       tokio::spawn(async move {
           loop {
               tokio::time::sleep(interval).await;
               
               let mut processes = manager.processes.lock().await;
               
               // 清理超过 1 小时没有 child 的记录
               let cutoff = Utc::now() - chrono::Duration::hours(1);
               processes.retain(|_, info| {
                   if info.child.is_none() && info.started_at < cutoff {
                       false
                   } else {
                       true
                   }
               });
           }
       });
   }
   ```

**验收标准：**
- ✅ 手动关闭浏览器后自动更新状态
- ✅ 崩溃后能检测到并更新状态
- ✅ 数据库状态与内存状态一致
- ✅ 无僵尸进程残留

**预计时间：** 0.5-1 天

---

## Phase BE-3：窗口群控稳定性增强（1-3 天）

### [任务 3.1] PID→HWND 识别更稳

**目标：** Chromium 多窗口情况下过滤主窗口（标题/样式/可见性），加重试与延迟

**具体步骤：**

1. **改进窗口枚举**
   ```rust
   use winapi::um::winuser::*;
   use winapi::shared::windef::HWND;
   
   struct WindowInfo {
       hwnd: HWND,
       title: String,
       class_name: String,
       is_visible: bool,
       style: u32,
   }
   
   fn get_window_info(hwnd: HWND) -> Option<WindowInfo> {
       unsafe {
           let mut title = vec![0u16; 256];
           let len = GetWindowTextW(hwnd, title.as_mut_ptr(), title.len() as i32);
           let title = String::from_utf16_lossy(&title[..len as usize]);
           
           let mut class_name = vec![0u16; 256];
           let len = GetClassNameW(hwnd, class_name.as_mut_ptr(), class_name.len() as i32);
           let class_name = String::from_utf16_lossy(&class_name[..len as usize]);
           
           let is_visible = IsWindowVisible(hwnd) != 0;
           let style = GetWindowLongW(hwnd, GWL_STYLE) as u32;
           
           Some(WindowInfo {
               hwnd,
               title,
               class_name,
               is_visible,
               style,
           })
       }
   }
   ```

2. **主窗口过滤规则**
   ```rust
   fn is_main_browser_window(info: &WindowInfo) -> bool {
       // 必须可见
       if !info.is_visible {
           return false;
       }
       
       // 必须有标题（排除空白窗口）
       if info.title.is_empty() {
           return false;
       }
       
       // 排除 DevTools 窗口
       if info.title.contains("DevTools") {
           return false;
       }
       
       // 排除扩展窗口
       if info.class_name.contains("Extension") {
           return false;
       }
       
       // 必须有标准窗口样式
       let has_caption = info.style & WS_CAPTION != 0;
       let has_sysmenu = info.style & WS_SYSMENU != 0;
       
       has_caption && has_sysmenu
   }
   ```

3. **添加重试机制**
   ```rust
   async fn find_window_with_retry(
       pid: u32,
       max_retries: u32,
       retry_delay: Duration
   ) -> Result<HWND, String> {
       for attempt in 0..max_retries {
           if attempt > 0 {
               tokio::time::sleep(retry_delay).await;
           }
           
           let windows = find_windows_by_pid(pid);
           let main_windows: Vec<_> = windows
               .into_iter()
               .filter(|info| is_main_browser_window(info))
               .collect();
           
           if !main_windows.is_empty() {
               return Ok(main_windows[0].hwnd);
           }
           
           println!("尝试 {}/{}: 未找到主窗口，等待重试...", attempt + 1, max_retries);
       }
       
       Err(format!("在 {} 次尝试后仍未找到主窗口", max_retries))
   }
   ```

4. **窗口操作稳定性**
   ```rust
   #[tauri::command]
   async fn arrange_windows_grid(
       columns: u32,
       state: State<'_, AppState>
   ) -> Result<(), String> {
       let manager = &state.browser_manager;
       let processes = manager.processes.lock().await;
       
       let mut windows = Vec::new();
       
       // 收集所有运行中的窗口
       for (profile_id, info) in processes.iter() {
           if info.status == ProcessStatus::Running {
               // 使用重试机制查找窗口
               match find_window_with_retry(info.pid, 3, Duration::from_secs(1)).await {
                   Ok(hwnd) => windows.push(hwnd),
                   Err(e) => {
                       eprintln!("查找窗口失败 {}: {}", profile_id, e);
                   }
               }
           }
       }
       
       // 排列窗口
       arrange_windows_in_grid(&windows, columns)?;
       
       Ok(())
   }
   ```

**验收标准：**
- ✅ 10 个窗口 hide/show/grid 操作稳定
- ✅ 正确识别主窗口，不操作 DevTools
- ✅ 窗口未就绪时能重试
- ✅ 多显示器环境下正常工作

**预计时间：** 1-2 天

---

## 总体时间估算

> 说明：下表同时给出“原计划估算”和“基于当前代码的剩余工作量”。

| 任务 | 优先级 | 原计划估算 | 当前状态 | 预估剩余时间 |
|---|---:|---:|---|---:|
| BE-0 接口冻结/命令对齐 | P0 | 0.5 天 | 已完成 | 0 |
| BE-1.1 kernel_path 校验 | P0 | 0.5 天 | 已完成 | 0 |
| BE-1.2 user_data_dir 校验 | P0 | 0.5 天 | 已完成 | 0 |
| BE-1.3 启动限流/队列 | P0 | 1-1.5 天 | 部分完成 | 0.5-1 天 |
| BE-2.1 进程表完善 | P0 | 1 天 | 部分完成 | 0.5-1 天 |
| BE-2.2 事件推送 | P0 | 1.5-2 天 | 已完成 | 0-0.5 天（仅统一命名/补文档） |
| BE-2.3 异常回收 | P1 | 0.5-1 天 | 部分完成 | 0.5 天 |
| BE-3.1 窗口识别优化 | P1 | 1-2 天 | 未开始 | 1-2 天 |
| Group：CRUD + profile_count + 禁止删除非空 | P0 | 新增 | 未开始 | 1-2 天 |
| Fingerprint：子集 + 透传（受控 merge） | P0 | 新增 | 未开始 | 1-2 天 |
| **预计剩余（合计）** |  |  |  | **4.5-9 天** |

**建议执行顺序：**
1. BE-0（0.5 天）- 确保接口稳定
2. BE-1.1 + BE-1.2（1 天）- 基础校验
3. BE-2.2（2 天）- 事件推送（最关键）
4. BE-2.1（1 天）- 进程管理
5. BE-1.3（1.5 天）- 启动优化
6. BE-2.3（1 天）- 异常处理
7. BE-3.1（2 天）- 窗口优化

---

## 验收清单

### Phase BE-0
- [x] 所有 IPC 命令与文档一致（Profile/Settings/Browser/Window）
- [x] 参数名统一使用 camelCase
- [ ] 新增命令流程文档化（后续新增 Group 命令时需严格执行）

### Phase BE-1
- [x] kernel_path 校验通过单元测试
- [x] user_data_dir 自动创建且可写
- [ ] 批量启动 10 个窗口不卡顿（当前顺序批量 + 限流，仍需优化与明确失败语义）
- [x] 每个 profile 有独立数据目录

### Phase BE-2
- [x] 前端能实时收到状态变化事件（已实现 `profile:status_changed` / `browser:error`）
- [x] 手动关闭浏览器后状态自动更新（已实现后台 monitor 更新 DB 并发事件）
- [ ] 崩溃检测正常工作（目前可检测退出，但缺少退出原因/错误归因）
- [ ] 数据库状态与内存一致（大体一致，需补齐 stop/异常路径的边界一致性验证）
- [ ] 无内存泄漏（待压测/长稳验证）

### Phase BE-3
- [ ] 10 个窗口群控操作稳定
- [ ] 正确识别主窗口
- [ ] DevTools 不被误操作
- [ ] 窗口未就绪时能重试成功

---

## 注意事项

1. **代码质量**
   - 所有公共函数添加文档注释
   - 关键逻辑添加单元测试
   - 使用 `cargo clippy` 检查代码质量

2. **错误处理**
   - 错误信息要具体、可操作
   - 避免 `unwrap()`，使用 `?` 或 `map_err`
   - 记录详细的错误日志

3. **性能考虑**
   - 避免长时间持有锁
   - 使用异步操作避免阻塞
   - 定期清理无用数据

4. **测试**
   - 单元测试覆盖核心逻辑
   - 集成测试验证端到端流程
   - 压力测试验证稳定性

5. **文档**
   - 更新 IPC 接口文档
   - 添加代码注释
   - 记录重要设计决策
