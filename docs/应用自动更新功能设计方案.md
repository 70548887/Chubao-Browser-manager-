# 应用自动更新功能设计方案

## 一、架构概述

### 1.1 更新目标

本系统包含 **两个独立可更新组件**，需分别设计更新策略：

| 组件 | 当前版本 | 产物形式 | 更新频率 |
|------|---------|---------|---------|
| **启动器** (browser-manager) | v0.2.0 | NSIS 安装包 (.exe) | 低频，功能迭代时发布 |
| **Chromium 内核** | v146 | ZIP 压缩包 | 中频，指纹策略调整时发布 |

### 1.2 设计目标

- 自建后台 API 统一管控两个组件的版本发布
- 支持多下载源（自建 CDN、镜像加速、GitHub），国内用户优先加速源
- **所有网络请求走 Rust 后端**（reqwest），前端仅通过 Tauri IPC 调用
- 下载完成后 **必须校验 SHA256**，校验失败禁止安装
- 更新安装前 **优雅关闭** 所有浏览器实例和代理桥

### 1.3 架构图

```
┌──────────────────────────────────────────────────────────────────────┐
│                       客户端 (Tauri App)                              │
│                                                                       │
│  ┌──────────────┐  ┌──────────────┐  ┌────────────────────────────┐  │
│  │  前端 (Vue)   │  │ Rust 后端    │  │  自动检查（启动时/定时）     │  │
│  │  UI 展示层    │──│ 版本检测     │  │  后台静默检测               │  │
│  │  invoke 调用  │  │ 下载 + 校验  │  └────────────────────────────┘  │
│  │              │  │ 安装 + 重启  │                                   │
│  └──────────────┘  └──────┬───────┘                                   │
└───────────────────────────┼───────────────────────────────────────────┘
                            │ reqwest (HTTPS)
                            ▼
┌──────────────────────────────────────────────────────────────────────┐
│                    自建后台 API 服务 (独立部署)                         │
│                                                                       │
│  GET /api/app/check-update      ← 启动器版本检测                      │
│  GET /api/kernel/check-update   ← 内核版本检测                        │
│  POST /api/app/download-stat    ← 下载统计（可选）                     │
│                                                                       │
│  后台管理界面：发布版本 / 管理下载源 / 查看统计 / 灰度配置              │
└──────────────────────────────┬───────────────────────────────────────┘
                               │
                               ▼
┌──────────────────────────────────────────────────────────────────────┐
│                     多下载源（按优先级自动切换）                        │
│  ┌────────────────┐  ┌────────────────┐  ┌─────────────────────┐    │
│  │  自建 CDN      │  │  镜像加速       │  │  GitHub Releases    │    │
│  │  优先级: 1     │  │  优先级: 2      │  │  优先级: 3          │    │
│  │  (最快最稳定)  │  │  (国内加速)     │  │  (原始源/海外)      │    │
│  └────────────────┘  └────────────────┘  └─────────────────────┘    │
└──────────────────────────────────────────────────────────────────────┘
```

---

## 二、后端 API 设计

> **说明：** 后端为独立部署的 Web 服务（推荐 Node.js / Go / Python），使用 MySQL 数据库。
> 与客户端内置的 SQLite 无关。

### 2.1 启动器版本检测

**接口：** `GET /api/app/check-update`

**请求参数（Query String）：**
```
?version=0.2.0&platform=windows&arch=x86_64&client_id=xxxxx
```

**响应示例（有更新）：**
```json
{
  "code": 0,
  "message": "success",
  "data": {
    "has_update": true,
    "version": "1.0.0",
    "current_version": "0.2.0",
    "release_date": "2026-02-10T12:00:00Z",
    "release_notes": "### v1.0.0 更新内容\n\n- 新增自动更新功能\n- 优化启动速度\n- 修复若干已知问题",
    "mandatory": false,
    "min_version": "0.1.0",
    "file_size": 85620736,
    "file_hash": "sha256:a1b2c3d4e5f67890abcdef1234567890abcdef1234567890abcdef1234567890",
    "downloads": [
      {
        "id": 1,
        "name": "自建CDN（推荐）",
        "url": "https://cdn.chubao.com/releases/v1.0.0/browser-manager_1.0.0_x64-setup.exe",
        "priority": 1,
        "region": "cn"
      },
      {
        "id": 2,
        "name": "镜像加速",
        "url": "https://ghproxy.com/https://github.com/user/repo/releases/download/v1.0.0/browser-manager_1.0.0_x64-setup.exe",
        "priority": 2,
        "region": "cn"
      },
      {
        "id": 3,
        "name": "GitHub（海外）",
        "url": "https://github.com/user/repo/releases/download/v1.0.0/browser-manager_1.0.0_x64-setup.exe",
        "priority": 3,
        "region": "global"
      }
    ]
  }
}
```

**响应示例（无更新）：**
```json
{
  "code": 0,
  "message": "success",
  "data": {
    "has_update": false,
    "current_version": "1.0.0",
    "latest_version": "1.0.0"
  }
}
```

### 2.2 内核版本检测

**接口：** `GET /api/kernel/check-update`

**请求参数：**
```
?version=146.0.7652.0&platform=win64&launcher_version=0.2.0
```

**响应示例：**
```json
{
  "code": 0,
  "message": "success",
  "data": {
    "has_update": true,
    "version": "146.0.7652.1",
    "current_version": "146.0.7652.0",
    "release_date": "2026-02-08T00:00:00Z",
    "release_notes": "修复 WebGL 指纹泄漏问题",
    "minimum_launcher_version": "0.2.0",
    "file_size": 180000000,
    "file_hash": "sha256:def456...",
    "downloads": [
      {
        "id": 10,
        "name": "自建CDN",
        "url": "https://cdn.chubao.com/kernel/v146.0.7652.1/chromium-kernel-win64.zip",
        "priority": 1,
        "region": "cn"
      }
    ]
  }
}
```

### 2.3 下载统计接口（可选）

**接口：** `POST /api/app/download-stat`

```json
{
  "component": "launcher",
  "version": "1.0.0",
  "source_id": 1,
  "client_id": "xxxxx",
  "platform": "windows",
  "arch": "x86_64",
  "success": true,
  "download_time_ms": 15000
}
```

---

## 三、服务端数据库设计

> 以下 SQL 为后端服务数据库（MySQL），**非客户端 SQLite**。

### 3.1 版本发布表 (app_releases)

```sql
CREATE TABLE app_releases (
    id              BIGINT PRIMARY KEY AUTO_INCREMENT,
    component       VARCHAR(20) NOT NULL COMMENT '组件：launcher / kernel',
    version         VARCHAR(30) NOT NULL COMMENT '版本号，如 1.0.0 或 146.0.7652.1',
    platform        VARCHAR(20) NOT NULL COMMENT '平台：windows/macos/linux/all',
    arch            VARCHAR(20) NOT NULL DEFAULT 'all' COMMENT '架构：x86_64/aarch64/all',
    release_notes   TEXT COMMENT '更新说明，Markdown 格式',
    release_date    DATETIME NOT NULL,
    mandatory       BOOLEAN DEFAULT FALSE COMMENT '是否强制更新',
    file_size       BIGINT COMMENT '文件大小（字节）',
    file_hash       VARCHAR(100) NOT NULL COMMENT 'sha256:xxx',
    min_version     VARCHAR(30) COMMENT '最低可升级版本（低于此版本需要全量安装）',
    min_launcher    VARCHAR(20) COMMENT '内核更新所需的最低启动器版本',
    enabled         BOOLEAN DEFAULT TRUE COMMENT '是否启用（用于灰度/回滚）',
    created_at      DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at      DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    UNIQUE KEY uk_component_version_platform (component, version, platform, arch),
    INDEX idx_enabled_component (enabled, component, platform)
) COMMENT '版本发布表（启动器 + 内核统一管理）';
```

### 3.2 下载源表 (app_download_sources)

```sql
CREATE TABLE app_download_sources (
    id              BIGINT PRIMARY KEY AUTO_INCREMENT,
    release_id      BIGINT NOT NULL COMMENT '关联版本 ID',
    name            VARCHAR(50) NOT NULL COMMENT '源名称',
    url             TEXT NOT NULL COMMENT '下载地址',
    priority        INT DEFAULT 1 COMMENT '优先级（越小越优先）',
    region          VARCHAR(20) DEFAULT 'global' COMMENT '适用地区：cn / global',
    enabled         BOOLEAN DEFAULT TRUE,
    created_at      DATETIME DEFAULT CURRENT_TIMESTAMP,

    FOREIGN KEY (release_id) REFERENCES app_releases(id) ON DELETE CASCADE,
    INDEX idx_release_priority (release_id, priority)
) COMMENT '下载源配置表';
```

### 3.3 下载统计表 (app_download_stats)

```sql
CREATE TABLE app_download_stats (
    id              BIGINT PRIMARY KEY AUTO_INCREMENT,
    component       VARCHAR(20) NOT NULL,
    version         VARCHAR(30) NOT NULL,
    source_id       BIGINT,
    client_id       VARCHAR(100),
    platform        VARCHAR(20),
    arch            VARCHAR(20),
    ip_address      VARCHAR(50),
    region          VARCHAR(50) COMMENT 'IP 归属地',
    success         BOOLEAN DEFAULT TRUE,
    download_time   INT COMMENT '下载耗时（毫秒）',
    created_at      DATETIME DEFAULT CURRENT_TIMESTAMP,

    INDEX idx_component_version (component, version, created_at),
    INDEX idx_source (source_id)
) COMMENT '下载统计表';
```

---

## 四、Rust 后端实现

### 4.1 新增模块：`src-tauri/src/modules/app_updater.rs`

此模块负责启动器和内核的版本检测、下载、校验、安装。

#### 4.1.1 数据结构

```rust
// src-tauri/src/modules/app_updater.rs

use anyhow::{Context, Result};
use futures_util::StreamExt;
use serde::{Deserialize, Serialize};
use sha2::{Sha256, Digest};
use std::path::{Path, PathBuf};
use tokio::fs::{self, File};
use tokio::io::AsyncWriteExt;
use tracing::{info, warn, error};

/// 更新组件类型
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum UpdateComponent {
    Launcher,
    Kernel,
}

/// 下载源
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DownloadSource {
    pub id: i64,
    pub name: String,
    pub url: String,
    pub priority: i32,
    pub region: String,
}

/// 更新信息（后端 API 返回）
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateInfo {
    pub has_update: bool,
    pub version: Option<String>,
    pub current_version: String,
    #[serde(default)]
    pub latest_version: Option<String>,
    pub release_date: Option<String>,
    pub release_notes: Option<String>,
    pub mandatory: Option<bool>,
    pub min_version: Option<String>,
    pub file_size: Option<u64>,
    pub file_hash: Option<String>,
    pub downloads: Option<Vec<DownloadSource>>,
}

/// API 统一响应
#[derive(Debug, Clone, Deserialize)]
pub struct ApiResponse<T> {
    pub code: i32,
    pub message: String,
    pub data: Option<T>,
}

/// 更新下载进度
#[derive(Debug, Clone, Serialize)]
pub struct UpdateDownloadProgress {
    pub component: String,
    pub downloaded: u64,
    pub total: u64,
    pub speed: u64,
    pub percent: u32,
    pub status: UpdateDownloadStatus,
    pub message: String,
}

/// 下载状态
#[derive(Debug, Clone, Serialize, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum UpdateDownloadStatus {
    Idle,
    Downloading,
    Verifying,
    Extracting,
    Completed,
    Failed,
}
```

#### 4.1.2 版本检测（走 Rust reqwest，非前端 fetch）

```rust
/// 更新服务器地址（生产环境替换）
const DEFAULT_UPDATE_SERVER: &str = "https://api.chubao.com";

/// 检查启动器更新
pub async fn check_launcher_update(
    server_url: &str,
    current_version: &str,
    platform: &str,
    arch: &str,
) -> Result<UpdateInfo> {
    let client = reqwest::Client::builder()
        .timeout(std::time::Duration::from_secs(10))
        .build()?;

    let url = format!(
        "{}/api/app/check-update?version={}&platform={}&arch={}",
        server_url, current_version, platform, arch
    );

    info!("Checking launcher update: {}", url);

    let resp: ApiResponse<UpdateInfo> = client
        .get(&url)
        .send()
        .await
        .context("请求更新服务器失败")?
        .json()
        .await
        .context("解析更新响应失败")?;

    if resp.code != 0 {
        return Err(anyhow::anyhow!("服务器返回错误: {}", resp.message));
    }

    resp.data.context("响应数据为空")
}

/// 检查内核更新
pub async fn check_kernel_update(
    server_url: &str,
    current_kernel_version: &str,
    platform: &str,
    launcher_version: &str,
) -> Result<UpdateInfo> {
    let client = reqwest::Client::builder()
        .timeout(std::time::Duration::from_secs(10))
        .build()?;

    let url = format!(
        "{}/api/kernel/check-update?version={}&platform={}&launcher_version={}",
        server_url, current_kernel_version, platform, launcher_version
    );

    info!("Checking kernel update: {}", url);

    let resp: ApiResponse<UpdateInfo> = client
        .get(&url)
        .send()
        .await
        .context("请求更新服务器失败")?
        .json()
        .await
        .context("解析更新响应失败")?;

    if resp.code != 0 {
        return Err(anyhow::anyhow!("服务器返回错误: {}", resp.message));
    }

    resp.data.context("响应数据为空")
}
```

#### 4.1.3 下载 + SHA256 强制校验

```rust
/// 下载文件并校验 SHA256
/// 返回下载后的文件路径
pub async fn download_and_verify(
    url: &str,
    expected_hash: &str,
    dest_dir: &Path,
    component: UpdateComponent,
    progress_callback: impl Fn(UpdateDownloadProgress) + Send + 'static,
) -> Result<PathBuf> {
    let client = reqwest::Client::builder()
        .user_agent("ChubaoUpdater/1.0")
        .redirect(reqwest::redirect::Policy::limited(10))
        .timeout(std::time::Duration::from_secs(600))
        .build()?;

    // 提取文件名
    let file_name = url.split('/').last().unwrap_or("download.tmp");
    let dest_path = dest_dir.join(file_name);

    // 确保目录存在
    fs::create_dir_all(dest_dir).await?;

    // 发起请求
    let response = client
        .get(url)
        .send()
        .await
        .context("下载请求失败")?;

    if !response.status().is_success() {
        return Err(anyhow::anyhow!("下载失败，HTTP {}", response.status()));
    }

    let total_size = response.content_length().unwrap_or(0);
    let mut downloaded: u64 = 0;
    let mut stream = response.bytes_stream();
    let mut file = File::create(&dest_path).await?;
    let mut hasher = Sha256::new();
    let start_time = std::time::Instant::now();
    let mut last_emit = std::time::Instant::now();
    let component_str = match component {
        UpdateComponent::Launcher => "launcher",
        UpdateComponent::Kernel => "kernel",
    };

    while let Some(chunk) = stream.next().await {
        let chunk = chunk.context("读取数据块失败")?;
        file.write_all(&chunk).await?;
        hasher.update(&chunk);
        downloaded += chunk.len() as u64;

        // 每 200ms 发送一次进度
        if last_emit.elapsed().as_millis() >= 200 {
            let elapsed = start_time.elapsed().as_secs_f64();
            let speed = if elapsed > 0.0 { (downloaded as f64 / elapsed) as u64 } else { 0 };
            let percent = if total_size > 0 {
                (downloaded as f64 / total_size as f64 * 100.0) as u32
            } else { 0 };

            progress_callback(UpdateDownloadProgress {
                component: component_str.to_string(),
                downloaded,
                total: total_size,
                speed,
                percent,
                status: UpdateDownloadStatus::Downloading,
                message: format!(
                    "下载中 {:.1} MB / {:.1} MB",
                    downloaded as f64 / 1_048_576.0,
                    total_size as f64 / 1_048_576.0
                ),
            });
            last_emit = std::time::Instant::now();
        }
    }

    file.flush().await?;
    drop(file);

    info!("下载完成: {} bytes -> {:?}", downloaded, dest_path);

    // ========== SHA256 强制校验 ==========
    progress_callback(UpdateDownloadProgress {
        component: component_str.to_string(),
        downloaded,
        total: total_size,
        speed: 0,
        percent: 100,
        status: UpdateDownloadStatus::Verifying,
        message: "正在校验文件完整性...".to_string(),
    });

    let hash_result = format!("{:x}", hasher.finalize());
    // 支持 "sha256:xxxx" 和 "xxxx" 两种格式
    let expected = expected_hash
        .strip_prefix("sha256:")
        .unwrap_or(expected_hash);

    if hash_result != expected {
        // 校验失败：删除文件，返回错误
        let _ = fs::remove_file(&dest_path).await;
        error!(
            "SHA256 校验失败！期望: {}, 实际: {}",
            expected, hash_result
        );
        return Err(anyhow::anyhow!(
            "文件完整性校验失败，文件可能已被篡改（期望: {}..., 实际: {}...）",
            &expected[..8.min(expected.len())],
            &hash_result[..8]
        ));
    }

    info!("SHA256 校验通过: {}", hash_result);
    Ok(dest_path)
}
```

#### 4.1.4 启动器安装（优雅关闭 + 启动安装器）

```rust
/// 安装启动器更新
/// 流程：检查运行实例 → 关闭浏览器 → 关闭代理桥 → 启动安装器 → 优雅退出
pub async fn install_launcher_update(
    installer_path: &Path,
    browser_manager: &crate::modules::BrowserManager,
    proxy_bridge_manager: &crate::modules::ProxyBridgeManager,
    app_handle: &tauri::AppHandle,
) -> Result<()> {
    // Step 1: 检查是否有运行中的浏览器实例
    let running = browser_manager.get_running_profiles().await;
    if !running.is_empty() {
        info!("正在关闭 {} 个运行中的浏览器实例...", running.len());
        for (profile_id, _pid) in &running {
            if let Some(mut child) = browser_manager
                .unregister_process(profile_id)
                .await
                .unwrap_or(None)
            {
                let _ = child.kill();
                let _ = child.wait();
            }
        }
        // 等待进程完全退出
        tokio::time::sleep(std::time::Duration::from_secs(2)).await;
    }

    // Step 2: 关闭所有代理桥
    info!("正在关闭代理桥...");
    proxy_bridge_manager.stop_all().await;

    // Step 3: 启动 NSIS 安装器（/S 静默安装）
    info!("启动安装器: {:?}", installer_path);
    #[cfg(target_os = "windows")]
    {
        use std::process::Command;
        Command::new(installer_path)
            .arg("/S")  // NSIS 静默安装参数
            .spawn()
            .context("启动安装器失败")?;
    }

    // Step 4: 通知前端即将退出
    let _ = app_handle.emit("app:will-restart", ());

    // Step 5: 优雅退出（让 Tauri 执行清理流程）
    tokio::time::sleep(std::time::Duration::from_millis(500)).await;
    app_handle.exit(0);

    Ok(())
}
```

#### 4.1.5 内核更新（ZIP 解压替换）

```rust
/// 安装内核更新
/// 前置条件：必须无运行中的浏览器实例
/// 流程：解压到临时目录 → 备份旧内核 → 替换 → 写入版本信息
pub async fn install_kernel_update(
    zip_path: &Path,
    kernel_dir: &Path,
    new_version: &str,
    browser_manager: &crate::modules::BrowserManager,
    progress_callback: impl Fn(UpdateDownloadProgress) + Send + 'static,
) -> Result<()> {
    // 前置检查：必须无运行中的浏览器
    let running = browser_manager.get_running_profiles().await;
    if !running.is_empty() {
        return Err(anyhow::anyhow!(
            "仍有 {} 个浏览器实例运行中，请先关闭所有浏览器再更新内核",
            running.len()
        ));
    }

    progress_callback(UpdateDownloadProgress {
        component: "kernel".to_string(),
        downloaded: 0, total: 0, speed: 0, percent: 0,
        status: UpdateDownloadStatus::Extracting,
        message: "正在解压内核文件...".to_string(),
    });

    // Step 1: 备份旧内核（如果存在）
    let backup_dir = kernel_dir.parent()
        .unwrap_or(kernel_dir)
        .join("kernel_backup");

    if kernel_dir.exists() {
        info!("备份旧内核到: {:?}", backup_dir);
        if backup_dir.exists() {
            fs::remove_dir_all(&backup_dir).await?;
        }
        fs::rename(kernel_dir, &backup_dir).await
            .context("备份旧内核失败")?;
    }

    // Step 2: 解压新内核
    fs::create_dir_all(kernel_dir).await?;

    let zip_path_owned = zip_path.to_path_buf();
    let dest_dir_owned = kernel_dir.to_path_buf();
    let extract_result = tokio::task::spawn_blocking(move || {
        let file = std::fs::File::open(&zip_path_owned)?;
        let mut archive = zip::ZipArchive::new(file)?;
        for i in 0..archive.len() {
            let mut entry = archive.by_index(i)?;
            let outpath = match entry.enclosed_name() {
                Some(path) => dest_dir_owned.join(path),
                None => continue,
            };
            if entry.name().ends_with('/') {
                std::fs::create_dir_all(&outpath)?;
            } else {
                if let Some(parent) = outpath.parent() {
                    std::fs::create_dir_all(parent)?;
                }
                let mut outfile = std::fs::File::create(&outpath)?;
                std::io::copy(&mut entry, &mut outfile)?;
            }
        }
        Ok::<_, anyhow::Error>(())
    }).await?;

    if let Err(e) = extract_result {
        // 解压失败：回滚
        error!("解压失败，正在回滚: {}", e);
        let _ = fs::remove_dir_all(kernel_dir).await;
        if backup_dir.exists() {
            let _ = fs::rename(&backup_dir, kernel_dir).await;
        }
        return Err(e.context("解压内核失败，已回滚到旧版本"));
    }

    // Step 3: 写入版本信息
    let version_info = serde_json::json!({
        "version": new_version,
        "build_date": chrono::Utc::now().to_rfc3339(),
        "platform": "win64",
        "source": "auto_update",
    });
    let version_file = kernel_dir.join("kernel_version.json");
    fs::write(&version_file, serde_json::to_string_pretty(&version_info)?)
        .await?;

    // Step 4: 清理备份和临时文件
    if backup_dir.exists() {
        let _ = fs::remove_dir_all(&backup_dir).await;
    }
    let _ = fs::remove_file(zip_path).await;

    info!("内核更新完成: {}", new_version);

    progress_callback(UpdateDownloadProgress {
        component: "kernel".to_string(),
        downloaded: 0, total: 0, speed: 0, percent: 100,
        status: UpdateDownloadStatus::Completed,
        message: format!("内核已更新到 {}", new_version),
    });

    Ok(())
}
```

### 4.2 Tauri Command 注册

在 `src-tauri/src/lib.rs` 中新增以下 commands：

```rust
// ==================== 更新相关 Commands ====================

/// 检查启动器更新
#[tauri::command]
async fn check_app_update(
    state: State<'_, AppState>,
) -> Result<modules::app_updater::UpdateInfo, String> {
    let server = get_setting(&state.pool, "update_server_url")
        .await?
        .unwrap_or_else(|| modules::app_updater::DEFAULT_UPDATE_SERVER.to_string());

    let current_version = env!("CARGO_PKG_VERSION");

    modules::app_updater::check_launcher_update(
        &server, current_version, "windows", "x86_64",
    )
    .await
    .map_err(|e| e.to_string())
}

/// 检查内核更新
#[tauri::command]
async fn check_kernel_update(
    state: State<'_, AppState>,
) -> Result<modules::app_updater::UpdateInfo, String> {
    let server = get_setting(&state.pool, "update_server_url")
        .await?
        .unwrap_or_else(|| modules::app_updater::DEFAULT_UPDATE_SERVER.to_string());

    let kernel_version = {
        let downloader = state.kernel_downloader.lock().await;
        downloader.get_installed_version()
            .map(|v| v.version)
            .unwrap_or_else(|| "0.0.0".to_string())
    };

    let launcher_version = env!("CARGO_PKG_VERSION");

    modules::app_updater::check_kernel_update(
        &server, &kernel_version, "win64", launcher_version,
    )
    .await
    .map_err(|e| e.to_string())
}

/// 下载启动器更新
#[tauri::command]
async fn download_app_update(
    app: tauri::AppHandle,
    url: String,
    file_hash: String,
) -> Result<String, String> {
    let temp_dir = std::env::temp_dir().join("chubao-update");

    let app_clone = app.clone();
    let dest = modules::app_updater::download_and_verify(
        &url,
        &file_hash,
        &temp_dir,
        modules::app_updater::UpdateComponent::Launcher,
        move |progress| {
            let _ = app_clone.emit("update:download-progress", &progress);
        },
    )
    .await
    .map_err(|e| e.to_string())?;

    Ok(dest.display().to_string())
}

/// 下载内核更新
#[tauri::command]
async fn download_kernel_update(
    app: tauri::AppHandle,
    url: String,
    file_hash: String,
) -> Result<String, String> {
    let temp_dir = std::env::temp_dir().join("chubao-update");

    let app_clone = app.clone();
    let dest = modules::app_updater::download_and_verify(
        &url,
        &file_hash,
        &temp_dir,
        modules::app_updater::UpdateComponent::Kernel,
        move |progress| {
            let _ = app_clone.emit("update:download-progress", &progress);
        },
    )
    .await
    .map_err(|e| e.to_string())?;

    Ok(dest.display().to_string())
}

/// 安装启动器更新（优雅关闭 + 启动安装器 + 重启）
#[tauri::command]
async fn install_app_update(
    app: tauri::AppHandle,
    state: State<'_, AppState>,
    file_path: String,
) -> Result<(), String> {
    let path = std::path::PathBuf::from(&file_path);
    modules::app_updater::install_launcher_update(
        &path,
        &state.browser_manager,
        &state.proxy_bridge_manager,
        &app,
    )
    .await
    .map_err(|e| e.to_string())
}

/// 安装内核更新（需要先关闭所有浏览器）
#[tauri::command]
async fn install_kernel_update(
    app: tauri::AppHandle,
    state: State<'_, AppState>,
    file_path: String,
    new_version: String,
) -> Result<(), String> {
    let zip_path = std::path::PathBuf::from(&file_path);
    let kernel_dir = state.app_data_dir.join("kernel").join("win32");

    let app_clone = app.clone();
    modules::app_updater::install_kernel_update(
        &zip_path,
        &kernel_dir,
        &new_version,
        &state.browser_manager,
        move |progress| {
            let _ = app_clone.emit("update:download-progress", &progress);
        },
    )
    .await
    .map_err(|e| e.to_string())
}

/// 获取运行中的浏览器数量（前端在安装更新前调用检查）
#[tauri::command]
async fn get_running_browser_count(
    state: State<'_, AppState>,
) -> Result<usize, String> {
    let running = state.browser_manager.get_running_profiles().await;
    Ok(running.len())
}
```

在 `.invoke_handler` 中注册：

```rust
.invoke_handler(tauri::generate_handler![
    // ... 现有 commands ...
    // Update commands
    check_app_update,
    check_kernel_update,
    download_app_update,
    download_kernel_update,
    install_app_update,
    install_kernel_update,
    get_running_browser_count,
])
```

### 4.3 模块导出

`src-tauri/src/modules/mod.rs` 新增：

```rust
pub mod app_updater;  // 应用自动更新
```

### 4.4 依赖变更

`Cargo.toml` 中 `sha2` 已存在，无需新增依赖。确认以下依赖可用：
- `sha2 = "0.10"` ✅ 已有
- `reqwest` ✅ 已有
- `futures-util` ✅ 已有
- `zip` ✅ 已有
- `chrono` ✅ 已有

---

## 五、前端实现

### 5.1 API 封装

**文件：** `src/api/updateApi.ts`

> **核心原则：前端不直接请求外部服务器，所有调用走 Tauri invoke。**

```typescript
import { invoke } from '@tauri-apps/api/core'
import { listen, type UnlistenFn } from '@tauri-apps/api/event'

// ==================== 类型定义 ====================

export interface DownloadSource {
  id: number
  name: string
  url: string
  priority: number
  region: string
}

export interface UpdateInfo {
  has_update: boolean
  version?: string
  current_version: string
  latest_version?: string
  release_date?: string
  release_notes?: string
  mandatory?: boolean
  file_size?: number
  file_hash?: string
  downloads?: DownloadSource[]
}

export interface UpdateDownloadProgress {
  component: string
  downloaded: number
  total: number
  speed: number
  percent: number
  status: 'idle' | 'downloading' | 'verifying' | 'extracting' | 'completed' | 'failed'
  message: string
}

// ==================== 启动器更新 ====================

/** 检查启动器更新 */
export async function checkAppUpdate(): Promise<UpdateInfo> {
  return await invoke<UpdateInfo>('check_app_update')
}

/** 下载启动器更新（Rust 后端执行，含 SHA256 校验） */
export async function downloadAppUpdate(url: string, fileHash: string): Promise<string> {
  return await invoke<string>('download_app_update', { url, fileHash })
}

/** 安装启动器更新（优雅关闭 → 启动安装器 → 重启） */
export async function installAppUpdate(filePath: string): Promise<void> {
  await invoke('install_app_update', { filePath })
}

// ==================== 内核更新 ====================

/** 检查内核更新 */
export async function checkKernelUpdate(): Promise<UpdateInfo> {
  return await invoke<UpdateInfo>('check_kernel_update')
}

/** 下载内核更新 */
export async function downloadKernelUpdate(url: string, fileHash: string): Promise<string> {
  return await invoke<string>('download_kernel_update', { url, fileHash })
}

/** 安装内核更新（需先关闭所有浏览器） */
export async function installKernelUpdate(filePath: string, newVersion: string): Promise<void> {
  await invoke('install_kernel_update', { filePath, newVersion })
}

// ==================== 辅助 ====================

/** 获取运行中的浏览器数量 */
export async function getRunningBrowserCount(): Promise<number> {
  return await invoke<number>('get_running_browser_count')
}

/** 监听下载进度事件 */
export function onUpdateProgress(
  callback: (progress: UpdateDownloadProgress) => void
): Promise<UnlistenFn> {
  return listen<UpdateDownloadProgress>('update:download-progress', (event) => {
    callback(event.payload)
  })
}

/** 监听应用即将重启事件 */
export function onAppWillRestart(callback: () => void): Promise<UnlistenFn> {
  return listen('app:will-restart', () => callback())
}

/** 格式化文件大小 */
export function formatFileSize(bytes: number): string {
  if (bytes < 1024) return `${bytes} B`
  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`
  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`
}

/** 格式化下载速度 */
export function formatSpeed(bytesPerSec: number): string {
  if (bytesPerSec < 1024) return `${bytesPerSec} B/s`
  if (bytesPerSec < 1024 * 1024) return `${(bytesPerSec / 1024).toFixed(1)} KB/s`
  return `${(bytesPerSec / (1024 * 1024)).toFixed(1)} MB/s`
}
```

### 5.2 Composable 逻辑

**文件：** `src/features/settings/useAppUpdate.ts`

```typescript
import { ref, onMounted, onUnmounted } from 'vue'
import { ElMessage, ElMessageBox } from 'element-plus'
import * as updateApi from '@/api/updateApi'

export function useAppUpdate() {
  // ========== 状态 ==========
  const launcherUpdate = ref<updateApi.UpdateInfo | null>(null)
  const kernelUpdate = ref<updateApi.UpdateInfo | null>(null)
  const isChecking = ref(false)
  const isDownloading = ref(false)
  const downloadProgress = ref<updateApi.UpdateDownloadProgress | null>(null)
  const downloadedFilePath = ref('')

  let unlistenProgress: (() => void) | null = null

  // ========== 检查更新 ==========
  const checkAllUpdates = async () => {
    isChecking.value = true
    try {
      const [launcher, kernel] = await Promise.allSettled([
        updateApi.checkAppUpdate(),
        updateApi.checkKernelUpdate(),
      ])

      if (launcher.status === 'fulfilled') {
        launcherUpdate.value = launcher.value
      }
      if (kernel.status === 'fulfilled') {
        kernelUpdate.value = kernel.value
      }

      const hasAny =
        launcherUpdate.value?.has_update || kernelUpdate.value?.has_update
      if (hasAny) {
        ElMessage.success('发现新版本可用')
      } else {
        ElMessage.info('当前已是最新版本')
      }
    } catch (error) {
      ElMessage.error(`检查更新失败: ${error}`)
    } finally {
      isChecking.value = false
    }
  }

  // ========== 下载并安装启动器 ==========
  const handleLauncherUpdate = async (source: updateApi.DownloadSource) => {
    if (!launcherUpdate.value?.file_hash) {
      ElMessage.error('缺少文件校验信息，无法安全更新')
      return
    }

    isDownloading.value = true
    try {
      const filePath = await updateApi.downloadAppUpdate(
        source.url,
        launcherUpdate.value.file_hash
      )
      downloadedFilePath.value = filePath

      await ElMessageBox.confirm(
        '下载完成且校验通过，是否立即安装？安装时程序将自动关闭并重启。',
        '安装启动器更新',
        { confirmButtonText: '立即安装', cancelButtonText: '稍后安装', type: 'success' }
      )

      await updateApi.installAppUpdate(filePath)
    } catch (error: any) {
      if (error !== 'cancel') {
        ElMessage.error(`更新失败: ${error}`)
      }
    } finally {
      isDownloading.value = false
    }
  }

  // ========== 下载并安装内核 ==========
  const handleKernelUpdate = async (source: updateApi.DownloadSource) => {
    if (!kernelUpdate.value?.file_hash || !kernelUpdate.value?.version) {
      ElMessage.error('缺少文件校验信息，无法安全更新')
      return
    }

    // 检查运行中的浏览器
    const runningCount = await updateApi.getRunningBrowserCount()
    if (runningCount > 0) {
      ElMessage.warning(`请先关闭所有运行中的浏览器（当前 ${runningCount} 个）`)
      return
    }

    isDownloading.value = true
    try {
      const filePath = await updateApi.downloadKernelUpdate(
        source.url,
        kernelUpdate.value.file_hash
      )

      await updateApi.installKernelUpdate(filePath, kernelUpdate.value.version)
      ElMessage.success(`内核已更新到 ${kernelUpdate.value.version}`)
      kernelUpdate.value = null
    } catch (error) {
      ElMessage.error(`内核更新失败: ${error}`)
    } finally {
      isDownloading.value = false
    }
  }

  // ========== 生命周期 ==========
  onMounted(async () => {
    const unlisten = await updateApi.onUpdateProgress((progress) => {
      downloadProgress.value = progress
    })
    unlistenProgress = unlisten
  })

  onUnmounted(() => {
    unlistenProgress?.()
  })

  return {
    launcherUpdate,
    kernelUpdate,
    isChecking,
    isDownloading,
    downloadProgress,
    checkAllUpdates,
    handleLauncherUpdate,
    handleKernelUpdate,
  }
}
```

### 5.3 UI 交互设计

**更新弹窗示意：**

```
┌─────────────────────────────────────────────────────────┐
│  发现新版本                                            X │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ┌─ 启动器 ─────────────────────────────────────────┐  │
│  │  v0.2.0  →  v1.0.0          大小: 81.6 MB       │  │
│  │                                                   │  │
│  │  更新内容:                                        │  │
│  │  - 新增自动更新功能                                │  │
│  │  - 优化启动速度                                   │  │
│  │  - 修复若干已知问题                               │  │
│  │                                                   │  │
│  │  下载源:                                          │  │
│  │  ● 自建CDN（推荐）                                │  │
│  │  ○ 镜像加速                                       │  │
│  │  ○ GitHub（海外）                                 │  │
│  └───────────────────────────────────────────────────┘  │
│                                                         │
│  ┌─ Chromium 内核 ──────────────────────────────────┐  │
│  │  v146.0.7652.0  →  v146.0.7652.1                │  │
│  │  修复 WebGL 指纹泄漏问题                          │  │
│  └───────────────────────────────────────────────────┘  │
│                                                         │
│  ⚠ 更新启动器将关闭所有浏览器窗口                       │
│                                                         │
├─────────────────────────────────────────────────────────┤
│  ═══════════════════░░░░░░░░░░ 45%  2.3 MB/s           │
├─────────────────────────────────────────────────────────┤
│                [ 稍后提醒 ]    [ 立即更新 ]              │
└─────────────────────────────────────────────────────────┘
```

**更新入口：**

| 场景 | 行为 |
|------|------|
| 应用启动 | 后台静默检测（读取 `auto_check_update` 设置），有更新时侧边栏显示红点 |
| 设置页面 | "检查更新" 按钮 + 自动检查开关 |
| 标题栏 | 有更新时显示 ↑ 图标，点击弹出更新弹窗 |

### 5.4 客户端设置项

存入 SQLite `settings` 表（通过现有 `set_setting_value` / `get_setting_value`）：

| Key | 类型 | 默认值 | 说明 |
|-----|------|-------|------|
| `auto_check_update` | string | `"true"` | 启动时自动检测更新 |
| `update_server_url` | string | `"https://api.chubao.com"` | 更新服务器地址（可自定义） |

---

## 六、安全设计

### 6.1 文件完整性校验（强制）

- 服务端发布版本时 **必须** 提供 SHA256 哈希值
- 客户端下载过程中 **流式计算** 哈希，下载完成立即比对
- 校验失败 → 删除文件 → 返回错误，**禁止安装**
- 实现位置：`app_updater::download_and_verify()`

### 6.2 传输安全

- 所有 API 和下载链接 **必须使用 HTTPS**
- Rust 端 reqwest 默认验证 SSL 证书（已使用 `rustls-tls`）
- **不允许** 前端 WebView 直接请求外部服务器（避免 CSP / CORS 问题）

### 6.3 安装安全

- 启动器更新：NSIS 安装器使用 `/S` 静默安装，覆盖旧版本
- 内核更新：先备份旧内核 → 解压新内核 → 失败则自动回滚
- 安装前 **必须** 先优雅关闭所有浏览器进程和代理桥

### 6.4 代码签名（推荐）

生产环境建议为 NSIS 安装包添加 Windows 代码签名证书：

```powershell
# 构建时设置签名
# tauri.conf.json → bundle.windows.certificateThumbprint
```

---

## 七、开发规范与要求

### 7.1 Rust 后端规范

| 规范项 | 要求 |
|--------|------|
| **模块位置** | 新增 `src-tauri/src/modules/app_updater.rs`，在 `mod.rs` 中注册 |
| **错误处理** | 使用 `anyhow::Result`，`tauri::command` 返回 `Result<T, String>` |
| **日志** | 所有关键步骤使用 `tracing::{info, warn, error}` 记录 |
| **网络请求** | 统一使用 `reqwest`，设置合理超时（检测 10s，下载 600s） |
| **异步** | 所有 IO 操作使用 `tokio::fs`，阻塞操作用 `spawn_blocking` |
| **事件** | 进度事件通过 `app.emit()` 推送，事件名前缀 `update:` |
| **文件路径** | 临时下载使用 `std::env::temp_dir().join("chubao-update")`，内核使用 `app_data_dir/kernel/win32` |
| **哈希校验** | 下载过程中流式计算 SHA256，禁止下载后再读文件计算（减少 IO） |
| **回滚** | 内核更新必须先备份再替换，失败自动回滚 |

### 7.2 前端规范

| 规范项 | 要求 |
|--------|------|
| **API 层** | 新建 `src/api/updateApi.ts`，所有更新操作通过 `invoke` 调用 Rust |
| **禁止事项** | **禁止** 在前端使用 `fetch` / `XMLHttpRequest` 请求外部更新服务器 |
| **Composable** | 新建 `src/features/settings/useAppUpdate.ts`，封装更新状态逻辑 |
| **UI 组件** | 更新弹窗使用 Element Plus `ElDialog` + `ElProgress`，遵循项目 UI 规范 |
| **事件监听** | 使用 `@tauri-apps/api/event` 的 `listen`，组件卸载时 `unlisten` |
| **类型** | 所有接口返回类型在 `updateApi.ts` 中定义，与 Rust `Serialize` 结构对齐 |
| **错误处理** | 所有 `invoke` 调用包裹 try/catch，用 `ElMessage.error` 展示错误 |
| **国际化** | 更新相关文案放入 `vue-i18n` 的 locale 文件（后续 i18n 集成时） |

### 7.3 接口对齐要求

前端 TypeScript 类型与 Rust 结构体 **必须一一对应**：

```
Rust                              TypeScript
────────────────────────────      ────────────────────────────
UpdateInfo                   →    UpdateInfo
UpdateDownloadProgress       →    UpdateDownloadProgress
DownloadSource               →    DownloadSource
UpdateComponent              →    (字符串 "launcher" | "kernel")
UpdateDownloadStatus         →    (字符串联合类型)
```

Rust 端 `#[serde(rename_all = "lowercase")]` 或 `#[serde(rename_all = "camelCase")]` 需与前端字段名风格保持一致。本方案统一使用 **snake_case**（与现有 `kernelApi.ts` 保持一致）。

### 7.4 测试要求

| 测试类型 | 内容 |
|---------|------|
| **Rust 单元测试** | `download_and_verify` 的 SHA256 校验逻辑（正确哈希 / 错误哈希） |
| **Rust 单元测试** | `check_launcher_update` / `check_kernel_update` 的响应解析 |
| **集成测试** | 启动器更新全流程：检测 → 下载 → 校验 → 安装器启动 |
| **集成测试** | 内核更新全流程：检测 → 下载 → 校验 → 解压替换 → 回滚验证 |
| **前端测试** | `useAppUpdate` composable 的状态流转（mock invoke） |

---

## 八、发布流程

### 8.1 版本发布检查清单

```
□ 1. 同步更新三处版本号：
     □ package.json          → "version": "x.y.z"
     □ src-tauri/Cargo.toml  → version = "x.y.z"
     □ src-tauri/tauri.conf.json → "version": "x.y.z"
□ 2. 编写更新说明 (Release Notes, Markdown 格式)
□ 3. 构建签名安装包
     □ 设置 TAURI_SIGNING_PRIVATE_KEY 环境变量（如使用代码签名）
     □ npm run tauri build
     □ 计算产物 SHA256：certutil -hashfile <file> SHA256
□ 4. 上传安装包到各下载源
     □ 自建 CDN
     □ GitHub Releases
     □ 镜像服务器（可选）
□ 5. 在后台管理系统发布新版本
     □ 填写版本号、平台、SHA256 哈希
     □ 配置下载源及优先级
     □ 设置是否强制更新
□ 6. 测试更新流程
     □ 旧版本客户端 → 检测到新版 ✓
     □ 下载完成 → SHA256 校验通过 ✓
     □ 各下载源可用性 ✓
     □ 安装流程正常 ✓
     □ 启动器重启后版本号正确 ✓
□ 7. 启用版本发布（enabled = true）
```

### 8.2 CI/CD 集成建议 (GitHub Actions)

```yaml
name: Build & Release
on:
  push:
    tags: ['v*']

jobs:
  build:
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: 20 }
      - uses: dtolnay/rust-toolchain@stable

      - run: npm ci
      - name: Build Tauri
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: npm run tauri build

      - name: Compute SHA256
        run: certutil -hashfile "src-tauri/target/release/bundle/nsis/*.exe" SHA256

      - name: Upload to Release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            src-tauri/target/release/bundle/nsis/*.exe
            src-tauri/target/release/bundle/nsis/*.exe.sig
```

### 8.3 镜像加速地址参考

| 服务 | 地址格式 | 说明 |
|------|---------|------|
| ghproxy | `https://ghproxy.com/` + 原地址 | 免费，不稳定 |
| 自建 CDN | 自定义域名 | 完全可控，推荐 |

---

## 九、后续优化

| 优化项 | 说明 | 优先级 |
|--------|------|--------|
| **增量更新** | 只下载变更部分，减少下载体积，需服务端生成差异包 | P2 |
| **静默更新** | 后台下载完成后缓存，下次启动时自动安装 | P2 |
| **灰度发布** | 按 `client_id` 哈希分桶，逐步推送，支持回滚 | P1 |
| **断点续传** | 下载中断后从断点继续，需服务端支持 Range 请求 | P2 |
| **多平台** | macOS / Linux 支持（DMG / AppImage 对应安装方式） | P3 |

---

## 十、文件变更总览

| 文件 | 操作 | 说明 |
|------|------|------|
| `src-tauri/src/modules/app_updater.rs` | **新增** | 更新检测、下载校验、安装（核心模块） |
| `src-tauri/src/modules/mod.rs` | 修改 | 新增 `pub mod app_updater` 和导出 |
| `src-tauri/src/lib.rs` | 修改 | 新增 7 个 `#[tauri::command]`，注册到 `invoke_handler` |
| `src/api/updateApi.ts` | **新增** | 前端更新 API 封装（invoke 调用） |
| `src/features/settings/useAppUpdate.ts` | **新增** | 更新逻辑 composable |
| `src/features/settings/SettingsView.vue` | 修改 | 新增"检查更新"卡片 UI |
